# Мотивация [00:05]
## Хотим обобщить
* `std::distance` должен работать для разных итераторов по-разному (уже известно)
* `vector<>` должен делать `move` или `copy` элементов в зависимости от noexcept
* `std::any`/`std::function` — хотим small object optimization. Надо менять поведение в зависимости от того, что скормили в конструктор.

## Хотим, чтобы компилятор делал рутину за нас
* Запустить много алгоритмов на одних и тех же данных и проверить, что будет.
* Вывести на экран сложный класс с векторами и мэпами, но описать это просто: TODO
* "Регистрируем" функции в интерпретаторе арифметических выражений
* Dependency injection

## Какие проблемы появятся
* Время компиляции
* Потенциально сложный код, метапрограммирование в C++ "открыли", а не придумали

# Базовые конвенции [00:15]
## Вычисления без constexpr [00:01]
* Можно использовать любые конструкции языка.
* Можно объявлять свои классы, поля, переменные.
* Можно менять переменные.
* Можно выделять память.

## Вычисления с constexpr [00:02]
* Можно использовать многие конструкции языка: нельзя `goto` и не-`constexpr` функции.
* Можно использовать скалярные типы и типы с `constexpr`-конструктором и тривиальным деструктором (вроде `optional` от простых типов).
* Всё ещё можно менять переменные внутри функций!
* До C++20 нельзя выделять память => нельзя `vector`
```c++
constexpr int factorial(int n) {
    int res = 1;
    for (int i = 1; i <= n; i++)
        res *= i;
    return res;
}
static_assert(factorial(5) == 120);
```

## Строковые литералы [00:05]
* Нет `constexpr strlen`, но всё ещё можно делать цикл до `s[i]`.
* Лучше не `const char *s`, а `const char (&s)[N]` с шаблонным `N`
* Можно парсить в compile-time:
```c++
template<size_t N>
constexpr auto count_specifiers(const char (&s)[N]) {
    int specifiers = 0;
    array<char, N> found{};
    for (size_t i = 0; i < N; i++) {
        if (s[i] == '%') {
            if (i + 1 >= N)
                throw std::logic_error("Expected specifier after %");
            i++;
            found[specifiers++] = s[i];
            if (!(s[i] == 'd' || s[i] == 'c' || s[i] == 's'))
                throw std::logic_error("Unknown specifier");
        }
    }
    return pair{specifiers, found};
}
static_assert(count_specifiers("hello%d=%s").first == 2);
static_assert(count_specifiers("hello%d=%s").second[0] == 'd');
static_assert(count_specifiers("hello%d=%s").second[1] == 's');
```
* Так можно распарсить что угодно и получить информацию для дальнейшего исследования.

## Виды вычислений во время компилции [00:07]
* Ещё с C++98 бывают функции из типов в типы:
  ```c++
  template<typename T>
  struct iterator_traits {  // Общий случай
      using value_type = typename T::value_type;
      using difference_type = typename T::difference_type;
  };
  template<typename T>
  struct iterator_traits<T*> {  // Частный случай
      using value_type = T;
      using difference_type = std::size_t;
  };
  ```
* Если такая "функция" возвращает ровно один тип, то обычно его называют `type`
  ```c++
  // remove_const
  ```
  * Как использовать: `typename ...::type`.
  * С C++11 есть конвенция создавать template using с суффиксом `_t`, тогда typename не нужен.
    Получаем вызов функции, только `<>` вместо `()`, и в качестве параметров — и значения, и типы.
* Ещё с C++98 иногда нужно вернуть ровно одно число.
  * Пример реализации `std::rank<int[][]>::value == 2`
    * Ещё давным-давно вместо `static constexpr` писали `enum { value = 10 }`, потому что бажные компиляторы: https://stackoverflow.com/a/205000/767632
  * Конкретно тут не хватит `constexpr`-функции, потому что потребуются частичные реализации функций + перегрузки.
  * Как использовать: `::value`
  * `integral_constant`, `bool_constant`, `true_type`, `false_type`
  * С C++17 есть конвенция создавать template variable с суффиксом `_v`.
    Получаем вызов функции, только `<>` вместо `()`, и в качестве параметров — и значения, и типы.
* С числами в параметрах бывают ограничения:
  ```c++
  template<typename T, T N> struct fac { .... };
  template<typename T>      struct fac<T, 0> { .... };  // Упс :(
  ```
  * Их можно обходить как раз при помощи дополнительного уровня `integral_constant`:
    ```c++
    template<typename N> struct fac {};  // Базовый случай, не вызывается.
    template<typename T, T N> constexpr auto fac_v = fac<std::integral_constant<T, N>>::value;
    template<typename T, T N> struct fac<std::integral_constant<T, N>> : std::integral_constant<T, N * fac_v<T, N - 1>> {};
    template<typename T>      struct fac<std::integral_constant<T, 0>> : std::integral_constant<T, 1> {};
    static_assert(fac_v<int, 5> == 120);
    ```

# Type traits [00:20]
* Нестрогое определение: такие классы/структуры, которые только
  таскают информацию в типах,  называются "типажи" (traits).
* Например, есть встроенные в язык "кирпичики" из `type_traits`:
  * Реализация `is_same`
  * `is_convertible` (без реализации)
  * `is_constructible` (без реализации)
  * Реализация `is_integral`
  * `is_polymorphic` (нельзя реализовать)
  * `remove_cv`
  * Некоторые можно написать самому или взять `boost::function_traits`
    ```c++
    template<typename T>
    struct function_traits {};
    template<typename Ret, typename Arg0>  // Можно написать обобщённо для N аргументов (variadic template), пока не будем.
    struct function_traits<Ret(Arg0)> {
        static constexpr std::size_t arity = 1;
        using return_value = Ret;
        using arg_0 = Arg0;
    };
    ```
* Некоторые traits предполагаются для расширения пользователем.
  * `iterator_traits` — по умолчанию берёт `typename` изнутри типа, но мы вольны
    дать свою интерпретацию любому типу вообще.
  * `char_traits` — по умолчанию даёт `char_type`/`int_type`, `eof()`/`eq`
    для `char`/`wchar_t` и ещё кого-то, но мы можем добавлять свои.
    * Например, сделать обёртку `case_insensitive_char` и для неё специализировать.
    * Или вообще в `basic_string` напрямую передать
* Так можно любые типы адаптировать под любую библиотеку.
  Например, сделать свою библиотеку (де)сериализации и сделать `serialization_trait`
  с двумя статическими функциями.
  * А потом пользователи могут его для своих типов использовать.
  * А мы можем сказать, что реализация по умолчанию смотрит на какие-то методы.

# Свойства выражений [00:20]
* Про типы всё можем узнавать, теперь давайте что-нибудь узнаем про выражения и функции.

## Оператор `noexcept(....)` и `declval<>` [00:04]
* Возвращает `true`/`false` на этапе компиляции: верно ли, что выражение внутри `noexcept`.
* Пример: `int a = 10; static_assert(noexcept(a = 20));`.
* Внутри `noexcept` иногда нужно создать значение определённого типа, для
  этого есть `std::declval<int>()` (также есть `<int&>`; `<int&&>` эквивалентно `<int>`).
  * Это легально только если это значение никогда не может быть вычислено.

## Применение `noexcept` [00:05]
Полезно для условного `vector`:

* Если у элементов `is_nothrow_move_assignable`, то можно делать `operator=(vector&&)` без промежуточного буфера и получить строгую гарантию исключений.
* Если у элементов `is_nothrow_move_assignable`, то можно в `reserve` делать сразу `move` вместо копирований.
  Для этого даже есть сахар: `move_if_noexcept`, реализация.
* А можно делать у `optional::operator=()` условный `noexcept`, получим `noexcept(noexcept(....))`

## Оператор `sizeof` (напоминание) [00:01]
* Работает в двух режимах: от типов и от выражений.

## Оператор `decltype` [00:09]
Есть с C++11: `decltype(expr)` — это некоторый тип. Можно использовать везде, где нужен тип.
Работает одним из двух способов:

1. Если `expr` — имя сущности без скобок, то возвращаем её тип. "Как объявлено".
   Пример для переменной, ссылки, константной ссылки, rvalue-ссылки.
2. Иначе смотрим на тип выражение (он всегда без ссылок, но может быть константный).
   Дальше в зависимости от категории добавляем:
   * lvalue: `T&`
   * xvalue: `T&&`
   * prvalue: `T`

Тонкости:

* `decltype((a))` — это второй случай, а `decltype(a)` — первый. Тип отличается.
* `decltype(expr) x = expr;` отличается от `auto`: второй снимет константность и ссылки,
  а первый не снимет.
  Такое иногда нужно, для этого используется `decltype(auto)`, но про это через пару лекций.

Исторически до C++11 был только `sizeof`: нельзя было получить весь тип,
но можно было получить его размер.
Из-за этого полезли костыли, когда надо отличить два типа друг от друга,
но про это на следующей лекции.

Кстати, при помощи `template<typename> struct TD;` и `TD<Foo>();` можно получить в ошибке компиляции текстовое описание любого типа.

# Тонкости указателей [00:20]
## `std::addressof` [00:02]
* Оператор `&` теоретически можно перегружать.
  Поэтому если у вас есть объект `a` непонятного типа `T`,
  то `&a` может быть не указателем.
* Решение есть через `reinterpret_cast<char&>`, но лучше просто
  `std::addressof`

## Тип "функция" и "указатель на функцию" [00:05]
* Есть тип "указатель на функцию": `void(*)(int)`, это просто указатель.
  * Кстати, нешаблонная лямбда без захватов к нему преобразуется.
  * А ещё он категорически несовместим с `void*`. Исторически на некоторых машинах
    код и данные вообще в разной памяти лежат, размеры могут не сойтись: https://isocpp.org/wiki/faq/pointers-to-members#cant-cvt-fnptr-to-voidptr
    Хотя Linux пофиг: там функция `dlsym` возвращает `void*` >_<
* А есть тип "функция": `void(int)` или `int()`.
  * Скопировать нельзя, но неявно приводится к указателю на функцию. Пример.
  * В метапрограммировании обычно применяется для упрощения синтаксиса: `function<void(int)>`.

## Указатели на перегрузки функций [00:04]
* Если вы написали `&foo`, то это указатель на функцию.
  Но если `foo` перегружена, то типа у этого выражения нет (примерно как у brace-init-list).
* Тип появляется только когда вы напишите `int (*x)(int) = &foo;`, тогда перегрузка разрешится.
  Типы должны совпасть в точности.
* Это обычно ожидаемо работает, но с перегруженными функциями в метапрограммировании иногда бывают проблемы.
  Например, когда мы присваиваем в `auto` или в шаблонный параметр.
  * Решение: либо явно указать тип, либо лямбду (с фиксированными или `auto`-параметрами, если хотим перегрузки).

## Указатели на члены класса и функции [00:09]
https://isocpp.org/wiki/faq/pointers-to-members

* Можно взять адрес нестатического члена класса: поля или функции.
  * Только `&C::m`, `&(C::m)` нельзя.
  * Это такой типобезопасный `offsetof`
  * С методами есть все стандартные проблемы с выбором перегрузки.
  * Будет полезно в синтаксисе сериализатора.
* Тип записывается как `int C::*`/`int C::*my_type` (можно со скобками вокруг `C::*x`). И для функций похоже.
  * Для функций можно указать const-qualifier: https://isocpp.org/wiki/faq/pointers-to-members#memfnptr-to-const-memfn
  * Но вообще рекомендуют сделать `typedef`.
* Использовать можно при помощи `.*` и `->*`.
  * Можно обратиться к любому члену нужного типа. Поле прочитать/записать, метод вызвать.
  * Пример с доступом к точке.
  * Почему-то в умных указателях `->*` не перегружен :(
    Делаем `*` и `.*`
  * Но вообще рекомендуют использовать `std::invoke`: https://isocpp.org/wiki/faq/pointers-to-members#macro-for-ptr-to-memfn
* Есть касты к дочерним классам (потому что там функция точно есть). В обратную сторону тоже можно, но явно.
* При этом это категорически несовместимо с обычными указателями.
  * Поле — потому что это сдвиг внутри объекта. Не `void*`, не указатель на объект.
  * Функция — даже с указателем на обычную функцию. Например, потому что бывают виртуальные функции
    и виртуальное наследование. А с учётом разрешённых кастов нам может быть надо хранить сразу структуру, а не один указатель.
