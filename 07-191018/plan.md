# Долги по Си [00:30]
## Файлы
### Позиции в файле [00:05]
* Ещё бывает `fseek` и `ftell`, которые позволяют перемещаться внутри файла и
  читать из произвольного места.
  Получаем этакий массив, в котором можно быстро читать подряд идущие кусочки
  и медленно менять позицию.
  ```
  fseek(f, 10, SEEK_SET); // Начало файла.
  fseek(f, 10, SEEK_CUR); // Относительно текущей позиции.
  fseek(f, -10, SEEK_END); // Конец файла.
  ```
  При записи мы перезаписываем байты, не двигаем.
  Так можно придумать свою файловую систему внутри файла: например, `zip`-архив
  (оглавление в конце архива даёт смещения файлов).
* Ещё бывают memory-mapped file, но это специальная функция ОС.
  Позволяет работать в точности как с массивом.

### Посимвольный [00:05]
* `getc` — посимвольный ввод.
  Возвращает не `char`, а `int`, потому что надо уметь возвращать `EOF` (точно отрицательное число).
  Который может быть равен `-1`, тогда пересекается с диапазоном `char`.
* `ungetc` — полезно для `scanf`, когда ему надо посмотреть на следующий символ и не читать его.
  Можно вставить обратно в поток любой символ, но только один раз
  (был баг в `testlib.h`, когда не удавалось прочесть строчку длины 4095: github.com/MikeMirzayanov/testlib/issues/75).
  Странно работает с `fseek` и `ftell`.

## Стандартная библиотека [00:05]
* `strncpy` небезопасна, потому что забивает на завершающий ноль, на выходе получаем не C-строку.
  Лучше `strcpy_s`.
  А ещё `*ncpy` всегда забивает буфер нулями до конца: https://devblogs.microsoft.com/oldnewthing/?p=36773
* `memset(arr, 0, sizeof arr)`: заполняет массив байтом. Только одним, поэтому работает только с 0 и -1.
  Может жестить и заполнять, например, по четыре байта за раз, чтобы побыстрее было.

## Язык [00:15]
* Если вы что-то объявили/определили в файле, то это можно использовать только ниже:
  ```
  void foo(int n) { ... }
  void bar(int n) { ... }
  ```
  `bar` может вызвать `foo`, но не наоборот.
  Как лечить, если хотим взаимную рекурсию? Объявления наверху дописать.
* В частности, со структурами (forward declaration):
  ```
  struct foo;
  struct bar;
  struct foo { struct bar *x; }
  struct bar { struct foo *x; struct foo y; }
  ```
  Обратите внимание, что если тут попробовать объявить `bar` внутри `foo`, то всё равно не получится: incomplete type.
* `void*`: `+` и `-` запрещены, `*` тоже, но GCC их разрешает (`*` только внутри `sizeof`).
  Поэтому `-pedantic`:
  ```
  int *get(void *arr, size_t pos) {
      // return arr + pos * sizeof(int);
      return (int*)((char*)arr + pos * sizeof(int));
  }
  ```
* falsy/truthy (терминология из питона): `NULL`/`nullptr` и нули в числах — ложь, остальное — истина. Лучше так и использовать.
  ```
  int *x = malloc(n * sizeof(int));
  1 if (!x) { ... }
  2 assert(x);
  ```
* ```
  struct point { int x, y; }
  int main() {
      const struct point p = readPoint();
      p.x++;  // Не компилируется.
  }
  ```
  Глубокая константность в структурах. А вот так?
  ```
  const struct point *p = readPoint();
  p->x++; // Не компилируется.
  ```
  А вот так?
  ```
  struct point *const p = readPoint();
  p->x++; // Компилируется.
  ```
  Это не как `final` в Java. Там у нас все объекты передаются по указателям и `final` относится к указателю, как в последнем примере.

# C++ [00:50]
## Базовые отличия от Си [00:10]
* Не надо писать `struct` даже без `typedef`.
* Есть тип `bool`, `true` и `false`.
* Надо компилировать при помощи `g++` вместо `gcc`.
* Можно использовать `const` для размера массива (если он известен на этапе компиляции).
* Обязательно указывать объявления функций:
  * Есть перегрузки.
  * Есть ссылки.
  * Есть параметры по умолчанию.
  * `int foo()` означает `foo` без параметров, писать `(void)` не надо.

## Базовая перегрузка функций [00:05]
* Есть перегрузка функций: можно написать
  ```
  int max(long long a, long long b);
  double max(double a, double b);
  ```
  Выберется "более подходящая", а в линкере произойдёт mangling:
  имя в объектном файле будет не в точности `max`, а `_Z3maxxx`/`_Z3maxdd` или что-то такое.
* Из-за этого напрямую Си и C++ не линкуются, но
  можно написать `extern "C"` и это отключит mangling для конкретной функции:
  ```
  extern "C" max(int a, int b);
  ```
* У двух функций с одинаковым именем `extern "C"` уже нельзя.

## Выделение памяти [00:10]
* Нельзя преобразовать `void*` в `char*` неявно.
* Вместо `malloc` и `free` принято использовать встроенные в язык операторы:
  ```
  char *arr = new int[10];
  delete[] arr;
  ```
  * Тут уже `sizeof` не нужен.
  * Нельзя смешивать `new`/`malloc`/`new[]`, это UB.

## Ссылки и объявления функций [00:10]
* Нельзя неявно использовать функцию, которая не определена и не объявлена:
  ```
  int main() {
      printf(...); // Ошибка без объявления.
  }
  ```
* Ссылки:
  ```
  int swap(int &a, int &b) {
      int t = a; a = b; b = t;
  }
  ```
  Аналогично работает с локальными переменными:
  ```
  int a = 10;
  int &b = a;
  a++;
  // b == 11
  // &a == &b
  ```
  * Поменять, куда указывает, нельзя.
  * Вариант А: "Второе имя" для переменной.
  * Вариант Б: всегда разыменованный указатель.
* Чем полезны: передавать без копирования:
  ```
  void print(Product p) { ... }
  void print(Product &p) { ... }
  void print(const Product &p) { ... }
  ```
  Очень, очень стандартно делать `const Product&`.
  Это так же безопасно, как и копия, но быстрее.
* Всё равно можно случайно получить "ссылку непонятно на что",
  но это не сегодня.

## Базовые конструкторы, деструкторы, методы [00:15]
* "Программирование — это управление абстракциями".
* Вот есть у вас массивы в Си и вектор в C++.
  На самом деле вектор "под капотом" делает то же самое, что и массивы в Си.
* Но вся сложность скрыта за простым интерфейсом, __инкапсулирована__ .
  Не надо возиться с указателями, `malloc`, `free`, беспокоиться об утечках.
* // Offtopic сейчас: cv-qualified methods, перегрузка операторов, `new` не инициализирует память для `int`, детали the most vexing parse. 
* Синтаксис в Си:
  ```
  struct int_array {
      int *data;
      size_t len;
  };
  void init_int_array(int_array *arr, size_t init_len) {
      arr->data = malloc(init_len * sizeof(int));
      arr->len = init_len;
  }
  void deinit_int_array(int_array *arr) {
      free(arr->data);
  }
  size_t len_int_array(int_array *arr) {
      return arr->len;
  }
  int get_int_array(int_array*, size_t);
  void set_int_array(int_array*, size_t, int);
  int main() {
      int_array x;
      init_int_array(&x, 10);
      for (size_t i = 0; i < len_int_array(&x); i++)
          set_int_array(&x, i, i * i);
      deinit_int_array(&x);
  }
  ```
  Всё канонично и инкапсулировано, но очень неудобно пользоваться по сравнению с массивами.
* Аналогичный синтаксис в C++:
  ```
  struct int_array {
  private: // Можно запретить доступ "снаружи", как в Java. В питоне такого скорее нет, если не считать __.
      int *data;  // "Поля". Как в структурах.
      size_t len;
  public:
      int_array(size_t init_len) { // Конструктор: имя "метода" совпадает с именем класса.
          // В отличие от Python не надо писать self., это как бы "глобальная" переменая.
          data = new int[init_len];
          len = init_len;
      }
      ~int_array() { // Деструктор.
          delete[] data;
      }
      size_t length() { return len; }
      int get(size_t x) { return data[x]; }
      void set(size_t x, int v) { data[x] = v; }
  };
  int main() {
      // int_array x;
      // int_array x(); // the most vexing parse.
      int_array x(10);
      for (size_t i = 0; i < x.length(); i++)
          x.set(i, i * i);
  }  // Автоматически вызывается деструктор, когда переменная исчезает.
  ```
