# План
Новая секция: "оборачивание кода библиотечным"

# Оборачивание асинхронного пользовательского кода библиотечным
`code/01-async`
http://artlang.net/post/konteyner-ssylok-c++-std-reference_wrapper/

* Хотим написать свой `std::thread`:
  * Сначала принимает `std::function` (`01-thread.cpp`).
    При этом тут мы не можем заменить его на лямбды: нам реально надо весь объект "функтор"
    передать одним указателем в `pthread_create`.
  * Потом делаем сахар, чтобы принимать много аргументов (`02-thread-args.cpp`).
  * Потом делаем свою обёртку с кастом к `T&`, чтобы можно было в том числе по ссылке передавать
    аргументы, а внутри thread копировать (`03-thread-args-ref.cpp`)
* Где ещё работает: конструктор `make_tuple` специально обрабатывает `reference_wrapper`.
* Можно использовать в STL для мутабельных функторов.

# Идеальный вызов функций
* Задача: `timed()`. Можно и старую конвенцию, но странно требовать `ref`/`cref` не по делу.
  Мы же почти макрос хотим.
  * То есть если в нас передали lvalue, то дальше хотим тоже передать lvalue. Передали rvalue, дальше хотим передать rvalue.
  * Forwarding reference, reference collapsing
  * Perfect forwarding
* Отличия конвенции от копирования всех аргументов, когда что применять
* decltype/decltype(auto) для возвращаемого типа и вообще (см. количество скобочек).
  * `return (x)` vs `return x;`
  * Возвращаемый тип — void? Можно делать return. Но нельзя объявить переменную типа void.
  * Решение: `if constexpr` + `std::is_same_v<void>`

# Parameter pack (variadic template)
Задача: много параметров в perfect forwarding
Синтаксис, группировка, sizeof…
БУДЕТ ПОТОМ: работа с индексами и более сложная распаковка-запаковка, несколько parameter pack

# Что можно получить
* `forward_as_tuple` (и понять, почему типы именно такие), `std::apply`, `std::invoke`
* Можно сделать мок: запоминает все вызовы, потом в тесте проверили.
* Теперь можно сделать объект `log`, который имеет `operator()` и логирует все вызовы и аргументы
  (если они форматируемые), при этом делает perfect forward и сам следит за вложенностью отступов.
