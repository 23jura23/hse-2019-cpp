# План
Новая секция: "оборачивание кода библиотечным"

# Оборачивание асинхронного пользовательского кода библиотечным
`code/01-async`
http://artlang.net/post/konteyner-ssylok-c++-std-reference_wrapper/

* Хотим написать свой `std::thread`:
  * Сначала принимает `std::function` (`01-thread.cpp`).
    При этом тут мы не можем заменить его на лямбды: нам реально надо весь объект "функтор"
    передать одним указателем в `pthread_create`.
  * Потом делаем сахар, чтобы принимать много аргументов (`02-thread-args.cpp`).
  * Потом делаем свою обёртку с кастом к `T&`, чтобы можно было в том числе по ссылке передавать
    аргументы, а внутри thread копировать (`03-thread-args-ref.cpp`)
* Где ещё работает: конструктор `make_tuple` специально обрабатывает `reference_wrapper`.
* Можно использовать в STL для мутабельных функторов.

# Идеальный вызов функций
* Задача: `timed()`. Можно и старую конвенцию, но странно требовать `ref`/`cref` не по делу.
  Мы же почти макрос хотим.
  * То есть если в нас передали lvalue, то дальше хотим тоже передать lvalue. Передали rvalue, дальше хотим передать rvalue.
  * Forwarding reference, reference collapsing
  * Perfect forwarding
* Отличия конвенции от копирования всех аргументов, когда что применять
* decltype/decltype(auto) для возвращаемого типа и вообще (см. количество скобочек).
  * `return (x)` vs `return x;`
  * Возвращаемый тип — void? Можно делать return. Но нельзя объявить переменную типа void.
  * Решение: `if constexpr` + `std::is_same_v<void>`

# Сохранение в поля при идеальном вызове
* Задача: emplace делаем макрос LOGGED(dfs)(....), который полностью выводит аргументы, делает отступы и возвращаемые значения. Тут нам потребуется разбирать случаи аргументов.
* Ссылки и константы в полях. Внутри контейнеров, пар, кортежей, structured binding, своих шаблонов. Что, когда, как.
  * Const tuple<int&> хранит внутри себя ссылку на неконстантный объект. Плохо играет со structured binding. Примерно как `const tuple<int*>`: https://stackoverflow.com/a/49309088/767632
* `forward_as_tuple` (и понять, почему типы именно такие), emplace, std::apply, std::invoke

# Parameter pack (variadic template)
Задача: много параметров в perfect forwarding
Синтаксис, группировка, sizeof…
БУДЕТ ПОТОМ: работа с индексами и более сложная распаковка-запаковка, несколько parameter pack
