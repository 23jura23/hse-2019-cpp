# Короткие обзоры [00:05]
* `if (auto it = m.find(key); it != m.end()) cout << it->second;`, также работает в ветке else.
  * Полезно для `dynamic_cast`
  * Полезно для `find()`
* Как правильно объявлять обычные константы и статические константы в заголовках для чисел, массивов символов, объектов (TODO).

# Structured binding и tuple [00:25]
## `std::tuple` [00:05]
https://en.cppreference.com/w/cpp/utility/tuple

* `tuple` и `make_tuple` для хранения элементов.
  * Гетерогенный список, пригодится в метапрограммировании, вроде `std::apply(fn, args)`, но про это потом.
  * Мне больше нравится `make_tuple`, потому что `tuple` может также означать копирование.
  * Можно даже делать `tuple_cat`
  * `tuple<A, B>` умеет понимать `pair<A, B>`
* `get<i>`, `tuple_size`
  * Нет циклов по `tuple`, это будет в метапрограммировании.
* Можно хранить ссылки, как и в `pair`.
  * Этим пользуется `std::tie`, который под капотом создаёт `tuple<>` из ссылок, который при присваивании вызывает `=` на элементах, получаем присваивание.
  * Но с этим много эффектов, аккуратно не сейчас.

## Structured binding [00:20]
https://en.cppreference.com/w/cpp/language/structured_binding

Мотивация:

* `[const/static/...] auto [a, b, c] = expr;` (также можно `]{...}` и `](...)`.
* Нельзя вложенно.
* Происходит на этапе компиляции: можно с массивами, но не с векторами.
* Удобно итерироваться по `map`.
* Удобно получать значения `pair` из `.insert`.

Как работает:

* Объявляем переменную, как если бы вместо `[a, b, c]` стояло некоторое уникальное `e`.
  * Тонкость: если `expr` — массив известного размера, то `e` сделаем такого же размера
    и скопируем элементы (copy-init для `=`, direct-init для `{}` и `()`).
  * Тип `e` обозначим `E` (без ссылок).
* Дальше привязываем элементы. Если массив, то каждый элемент — синоним для `e[0]`, `e[2]`...
* Если не массив, то пробуем как будто `tuple`:
  * Количество элементов должно совпадать с `std::tuple_size<E>::value`.
  * Дальше объявляем каждый элемент типа "ссылка на `std::tuple_element<i, E>::type`"
    * `i` — это исходно `std::size_t`.
    * ЗАБИТЬ: ссылка — либо lvalue, либо rvalue, в зависимости от инициализации
  * Инициализируем ссылку первым подходящим:
    * `e.get<i>()`
    * `get<i>(e)`
    * ЗАБИТЬ: здесь `e` делает perfect forwarding: если было lvalue (`auto&`), то остаётся lvalue.
              Иначе xvalue. Обычно нам пофиг, потому что всё равно везде ссылки.
    * Если попытаетесь сделать такое сами, то осторожно: 
  * Время жизни такое же, как и у `e`
* Иначе пробуем привязаться ко всем(!) нестатическим полям.
  Они должны быть доступны. Причём все поля должны лежать в одном классе
  (либо в нас, либо в ровно одном предке).

Примеры:

* В зависимости от `auto`/`auto&`/`const auto&` и инициализатора у нас получаются немного разные типы.
  * `auto` всегда скопирует объект целиком, а не просто его кусочки.
  * `auto&` попробует привязать ссылку, но не продлит жизнь временному объекту (не скомпилируется).
  * `const auto&` продлит жизнь временному объекту.
* `minmax`/`min`/`max` возвращают ссылки, из-за этого structured binding ломается: https://stackoverflow.com/a/51503253/767632

# RTTI [00:15]
Что такое RTTI?

* Компилятор сохраняет Run-Time Type Information на этапе компиляции.
* Для полиморфных типов (у которых хотя бы одна виртуальная функция) сохраняем в объект
  указатель на RTTI. Можно в таблицу виртуальных функций, а можно и по-другому.
* `dynamic_cast` смотрит на самом деле на RTTI и понимает по нему.

Второй способ получить RTTI в языке: `typeid(..)`

* Оператор возвращет `const type_info&` (некопируемый и неперемещаемый тип).
* У него можно спросить `==` и `!=`
* Можно спросить `name()`, получить белиберду
  * Может совпадать у разных типов, отличаться от запуска к запуску...
  * Можно расшифровать при помощи `boost::core::demangle` (иногда работает).
    * Пример кода
    * `sudo apt install libboost-all-dev`
* Чтобы можно было складывать в контейнеры, есть `std::type_index`,
  его уже можно копировать, сравнивать, класть в контейнеры
  * Не зависит от `name()`, использует `type_info::hash_code` и `type_info::before`
  * Можно написать свой, но незачем
* При этом ничего про тип узнать нельзя. Reflection отсутствует. Поля не перечислить.

Тонкости `typeid`

* От типа возвращает `const type_info&` на этапе компиляции
* От неполиморфного выражения не вычисляет его, а возвращает `const type_info&` на этапе компиляции (пример!)
* От полиморфного: вычисляет, возвращает `const type_info&` (если `nullptr`, то кидает `std::bad_typeid`).

Надо ли?

* Type erasure: не `void*`, а `std::any`.
  * Теперь можно копировать.
  * Теперь можно в рантайме проверять, что ничего не продолбали
* Исторически стоит дорого => редко используется => бывают баги и занимает много места
  * Во встраиваемом программировании отрубается `-fno-rtti`
  * Можно реализовать самому как библиотеку: Boost.TypeIndex

# Прочие ссылки, не на экзамен [00:05]
* User defined literals, не на экзамен: https://en.cppreference.com/w/cpp/language/user_literal
  * Пример из chrono: `auto duration = 10s` (секунд).
  * Пример для автовывода типов: `split(....) == vector{"foo"sv}` (иначе был бы `vector<char*>`).
  * Можно писать свои, можно даже парсить длинные числа руками.
* Был `dynamic_cast`. А для `shared_ptr` есть аналогичный `dynamic_pointer_cast` (и ещё три аналогичных `*_pointer_cast`).
  Это популярно для умных указателей, если вообще имеет смысл менять тип указателя, не меняя тип владения
  (для `unique_ptr` не имеет).
* CRTP:
  * https://en.wikibooks.org/wiki/More_C%2B%2B_Idioms/Curiously_Recurring_Template_Pattern
  * Можно реализовать для реализации `struct Point : operators<Point> { bool operator<(..); }`
  * Можно для вынесения любой другой функциональности в общего предка без виртуальных функций.
* Pimpl для выноса приватных полей и методов из заголовка и сохранения API/ABI. Ценой динамических выделений памяти.

# Argument-Dependent Lookup (ADL), Koenig search [00:30]
https://en.cppreference.com/w/cpp/language/adl
TODO

* ADL для поиска операторов и функций
  * Идея-1: формально находить `operator<<`
  * Идея-2: свободная функция в целом — кусок интерфейса класса
  * http://www.gotw.ca/gotw/030.htm
  * http://www.gotw.ca/publications/mill02.htm
  * ?? Посмотреть C++ Core Guidelines, C++ ISO FAQ, Мейерса, Александреску, ...
* Как писать `std::swap` и почему: https://stackoverflow.com/a/5695855
* Зачем нужен ADL, кроме операторов и костыльного swap (разрешить бы частичные специализации в `std::` и всё)
  * ADL-only
    * range-based-for поиск std::begin/std::end
    * Structured binding поиск `get<>` (просто глобальная функция не поможет).
      ОСТОРОЖНО: https://stackoverflow.com/a/45493969/767632
  * Поиск друзей: friend namespace injection в стандартном C++ нет, как добавить? 
* `namespace no_adl`+`using` для отключения случайного ADL?
  * Вызов конструктора не находится через ADL (и слава богу, теперь namespace no_adl работает). TODO
