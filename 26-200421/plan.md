# Короткие обзоры [00:05]
* `if (auto it = m.find(key); it != m.end()) cout << it->second;`, также работает в ветке else.
  * Полезно для `dynamic_cast`
  * Полезно для `find()`
* Функции:
  * https://herbsutter.com/2013/06/05/gotw-91-solution-smart-pointer-parameters/
  * Параметры лучше передавать по значению.
    * Если мы будем его куда-то копировать или перемещать — `T` и делаем `move`.
      * Не надо `&&` даже для `unique_ptr&&`, разрешите создаваться от чистых указателей (не то чтобы так надо).
    * Если только на чтение — `const T&`.
    * Если очень хочется поменять объект вызвавшему — `T&`.
    * Если требуется зануляемый объект — `optional` или `const T*`.
  * В параметре умный указатель возникает только если мы хотим думать про то, как им владеет __вызвавший__ . Обычно не хотим.
    * `const unique_ptr<T>&` не делаем вообще никогда, это эквивалентно `T&` (без `const`, кстати).
    * `const shared_ptr<T>&` не делаем почти никогда.
    * `unique_ptr<T>&` и `shared_ptr<T>&` тоже почти никогда.
    * Когда хотим: создаём дерево, у нас множество `unique_ptr<Node>`, не хотим лишний раз копировать и выделять память.
      * Тут принимаем `unique_ptr<Node>` и делаем move. Но могли бы принимать и `Node` и перевыделять память.

# Как объявлять константы [00:10]
* Если в `.cpp` или `.h`, не внутри классов:
  * Лучше с `constexpr` вместо `const`: https://github.com/isocpp/CppCoreGuidelines/blob/master/CppCoreGuidelines.md#Rconst-constexpr
    * Это не форсирует вычисление в compile-time, но проверяет, что оно возможно, запрещает проблемы с порядком инициализации.
  * `constexpr` не прокатит с `std::string`:
    * Можно просто `const`, означает "осторожно с порядком инициализации", он не определён между TU, было в начале года.
  * `const`, в отличие от переменных, имеют internal linkage и не торчат наружу.
    * Но адрес, разумеется, будет отличаться в разных единицах трансляции.
* Как объявлять статические константы-члены классов
  * Уже не internal linkage, а всегда external linkage.
  * Обязаны определить ровно один раз (ODR), как и любую функцию, но инициализатор
    можем писать как в объявлении (если хотим использовать как размер массива),
    так и в определении.
  * Компилятор иногда может не требовать определение даже по стандарту, но лучше не надо 
    экспериментировать (а то ill-formed, no diagnostics required).
    * Очень вероятно потребует, если брать адрес от константы:
      `static constexpr SIGNATURE[] = "HUFF";`
  * Идеальный способ: `static inline constexpr` (с C++17).
    Слово `inline` работает как для `inline`-функций: добавляет определения везде и
    требуется, чтобы они совпадали прямо по токенам.
    * Линковщик, скорее всего, выберет одно определение.
    * На самом деле для `static constexpr` слово `inline` автоматически, но давайте правила попроще.
* **Самое важное**: резюме:
  * Всегда `constexpr`, если очень хорошо понимаете, что делаете и зачем — `const` ("сэкономить пару байт" не аргумент, имхо).
  * В заголовках всегда `inline` (как и функции): https://abseil.io/tips/168
  * Иначе возможны нарушения ODR: ошибки линковки и UB.

# Structured binding и tuple [00:25]
## `std::tuple` [00:05]
https://en.cppreference.com/w/cpp/utility/tuple

* `tuple` и `make_tuple` для хранения элементов.
  * Гетерогенный список, пригодится в метапрограммировании, вроде `std::apply(fn, args)`, но про это потом.
  * Мне больше нравится `make_tuple`, потому что `tuple` может также означать копирование.
  * Можно даже делать `tuple_cat`
  * `tuple<A, B>` умеет понимать `pair<A, B>`
* `get<i>`, `tuple_size`, `tuple_element`
  * Нет циклов по `tuple`, это будет в метапрограммировании.
* **Можно пропустить**: можно хранить ссылки, как и в `pair`.
  * Этим пользуется `std::tie`, который под капотом создаёт `tuple<>` из ссылок, который при присваивании вызывает `=` на элементах, получаем присваивание.
  * Но с этим много эффектов, аккуратно не сейчас.

## Structured binding [00:20]
https://en.cppreference.com/w/cpp/language/structured_binding

### Мотивация [00:05]
* `[const/static/...] auto [a, b, c] = expr;` (также можно `]{...}` и `](...)`.
* Нельзя вложенно.
* Происходит на этапе компиляции: можно с массивами, но не с векторами.
* Удобно итерироваться по `map`.
* Удобно получать значения `pair` из `.insert`.

### Как работает [00:10]

* Объявляем переменную, как если бы вместо `[a, b, c]` стояло некоторое уникальное `e`.
  * Тонкость: если `expr` — массив известного размера, то `e` сделаем такого же размера
    и скопируем элементы (copy-init для `=`, direct-init для `{}` и `()`).
  * Тип `e` обозначим `E` (без ссылок).

**Можно пропустить**.

* Дальше привязываем элементы. Если массив, то каждый элемент — синоним для `e[0]`, `e[2]`...
* Если не массив, то пробуем как будто `tuple`:
  * Количество элементов должно совпадать с `std::tuple_size<E>::value`.
  * Дальше объявляем каждый элемент типа "ссылка на `std::tuple_element<i, E>::type`"
    * ЗАБИТЬ: `i` — это исходно `std::size_t`.
    * ЗАБИТЬ: ссылка — либо lvalue, либо rvalue, в зависимости от инициализации
  * Инициализируем ссылку первым подходящим:
    * `e.get<i>()`
    * `get<i>(e)`
    * ЗАБИТЬ: здесь `e` делает perfect forwarding: если было lvalue (`auto&`), то остаётся lvalue.
              Иначе xvalue. Обычно нам пофиг, потому что всё равно везде ссылки.
    * Если попытаетесь сделать такое сами, то осторожно: 
  * Время жизни такое же, как и у `e`
* Иначе пробуем привязаться ко всем(!) нестатическим полям.
  Они должны быть доступны. Причём все поля должны лежать в одном классе
  (либо в нас, либо в ровно одном предке).

### Примеры [00:05]
* В зависимости от `auto`/`auto&`/`const auto&` и инициализатора у нас получаются немного разные типы.
  * `auto` всегда скопирует объект целиком, а не просто его кусочки.
  * `auto&` попробует привязать ссылку, но не продлит жизнь временному объекту (не скомпилируется).
  * `const auto&` продлит жизнь временному объекту.
* `minmax`/`min`/`max` возвращают ссылки, из-за этого structured binding ломается: https://stackoverflow.com/a/51503253/767632

# RTTI [00:15]
Что такое RTTI?

* Компилятор сохраняет Run-Time Type Information на этапе компиляции.
* Для полиморфных типов (у которых хотя бы одна виртуальная функция) сохраняем в объект
  указатель на RTTI. Можно в таблицу виртуальных функций, а можно и по-другому.
* `dynamic_cast` смотрит на самом деле на RTTI и понимает по нему.

Второй способ получить RTTI в языке: `typeid(..)`

* Оператор возвращет `const type_info&` (некопируемый и неперемещаемый тип).
* У него можно спросить `==` и `!=`
* Можно спросить `name()`, получить белиберду
  * Может совпадать у разных типов, отличаться от запуска к запуску...
  * Можно расшифровать при помощи `boost::core::demangle` (иногда работает).
    * Пример кода
    * `sudo apt install libboost-all-dev`
* Чтобы можно было складывать в контейнеры, есть `std::type_index`,
  его уже можно копировать, сравнивать, класть в контейнеры
  * Не зависит от `name()`, использует `type_info::hash_code` и `type_info::before`
  * Можно написать свой, но незачем
* При этом ничего про тип узнать нельзя. Reflection отсутствует. Поля не перечислить.

Тонкости `typeid`

* От типа возвращает `const type_info&` на этапе компиляции
* От неполиморфного выражения не вычисляет его, а возвращает `const type_info&` на этапе компиляции (пример!)
* От полиморфного: вычисляет, возвращает `const type_info&` (если `nullptr`, то кидает `std::bad_typeid`).

Надо ли?

* Type erasure: не `void*`, а `std::any`.
  * Теперь можно копировать.
  * Теперь можно в рантайме проверять, что ничего не продолбали
* Исторически стоит дорого => редко используется => бывают баги и занимает много места
  * Во встраиваемом программировании отрубается `-fno-rtti`
  * Можно реализовать самому как библиотеку: Boost.TypeIndex

# Unqualified functions lookup, Argument-Dependent Lookup (ADL), Koenig search [00:30]
## Базовое про ADL [00:05]
http://www.gotw.ca/gotw/030.htm
https://stackoverflow.com/a/8111750/767632

* Пусть объявили класс в namespace и `operator<<`.
  Раз это функция, то почему её можно вызывать без `my_namespace::`?
  * Чтобы удобно было
  * Есть специальный механизм в языке: ADL, argument-dependent lookup.
  * Определение: если видим неквалифицированный вызов функции, то смотрим на типы
    аргументов и ищем функции во всех связанных namespace'ах.
* Более крутая идея: если мы вместе с классом дали пользователю какую-то функцию,
  то она должна иметь те же моральные права, что и класс.
  * http://www.gotw.ca/publications/mill02.htm
  * Пример: `begin()` и `end()` для range-based-for (тут можно только ADL, потому что мало ли где range-based-for используется).
  * Пример: `copy_file(from, to)` из Filesystem library, ей не нужен доступ к приватным полям.
  * Пример: `swap()` для обмена содержимым.

## Как и зачем работает `swap` [00:05]
https://stackoverflow.com/a/5695855

* Это шаблонная функция из `std::`.
* Её можно специализировать полностью.
* Но её нельзя специализировать частично (стандарт так не умеет с функциями), типа для `my_vector<T>`.
  Можно только добавить перегрузку, но стандарт запрещает добавлять свои функции и перегрузки в `std::`.
* Вывод: контейнеры могут только себе добавлять `void swap` в тот же namespace.
* Вывод: в обобщённом коде (да и в любом, на самом деле) мы должны делать вот так:
  ```
  using std::swap; // На случай, если стандартный через move+move+move подойдёт.
  swap(a, b); // Вызываем с ADL.
  ```

# Как работает ADL [00:10]
https://abseil.io/tips/49
https://en.cppreference.com/w/cpp/language/adl

Алгоритм

* Сначала поискали все имена функций в нужных namespace'ах.
  * Пошли от текущего scope наверх, пока не нашли кого-то с нужным именем. Включая `using`.
    Там остановились, выше не идём.
    Это первый namespace, в котором ищем.
    * Если нашли в этом namespace кого-то из трёх, то останавливаемся и ADL не включаем:
      * либо член класса (метод, поле, статическая функция или переменная)
      * ЗАБИТЬ: либо объявление функции block-scope(!) не через using
      * либо кого-то левого (не функцию) с таким же именем
  * Дополнительно сделали ADL: добавили все type-associated namespace для каждого аргумента.
    * Сначала ищем все типы, связанные с `T` (точный список не на экзамен, но надо знать, что он непустой):
      * Сам тип `T`.
      * Все родители и прародители `T`.
      * Класс `U`, в котором лежит `T` (самый верхний, уже лежащий в namespace).
      * Если шаблон, указатель, массив, функция — пошли рекурсивно в параметры.
    * Каждый тип (кроме `int`, `double`, ...) лежит в каком-то namespace.
      * Это после разворачивания всех type aliases (`typedef`, `using`). Пример.
      * Взяли ровно этот namespace, наверх не идём (пример).
      * При этом type aliases полностью разворачиваются.
* Теперь в каждом найденном namespace посмотрели на все функции с таким именем (включая `using`'и, но не включая `using namespace`).
  Выбрали перегрузку среди найденных.
  * Могут быть неоднозначности между ADL и обычным поиском. Пример.

Hidden friends:

* Объявили и определили функцию-друга внутри класса, и теперь достать можно только через ADL (кстати, inline врубается)
  * Pros: функции можно вызвать только через ADL (примерно как методы), сложнее опечататься.
  * Cons: теперь эту функцию нельзя никуда явно передать, только лямбдой.
  * Если такого не хотим, то можно объявить и/или определить вне класса, функция станет видна (friend name injection).
  * https://blog.panicsoftware.com/friends-and-where-to-find-them/
  * https://www.justsoftwaresolutions.co.uk/cplusplus/hidden-friends.html

## Тонкости ADL [00:03]
* При этом unqualified lookup также смотрит на конструкторы, а ADL смотрит только на функции. Пример.
* Есть тонкости с вызовом шаблонов с явными параметрами, они иногда не компилируются: https://stackoverflow.com/a/45493969/767632
  (ADL не в курсе, что это функция, как в предыдущем пункте).
  * Пример: `get<>()` для structured binding (тоже только ADL).
  * Пример: `duration_cast<>()` из chrono.

## Практические следствия ADL [00:07]
* С ADL надо осторожно:
  * `count(vec.begin(), vec.end())` может скомпилироваться или нет в зависимости от того,
    указатели там или вложенные классы.
    Лучше `std::count`, тогда ADL точно не будет.
  * В одной компании принято вложенный `namespace no_adl` с классами + `using` для отключения случайного ADL.
* Осторожно с передвиганием функций и типов в другие namespaces при рефакторинге.
* Если у вас вызывается странная функция без namespace — это ADL.
* Все вспомогательные функции определяйте строго в том же namespace, что и класс:
  * https://github.com/isocpp/CppCoreGuidelines/blob/master/CppCoreGuidelines.md#c5-place-helper-functions-in-the-same-namespace-as-the-class-they-support
  * https://github.com/isocpp/CppCoreGuidelines/blob/master/CppCoreGuidelines.md#c168-define-overloaded-operators-in-the-namespace-of-their-operands
* Пишите `using std::swap; swap(a, b)`.
