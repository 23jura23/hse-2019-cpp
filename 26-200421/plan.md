# Короткие обзоры [00:02]
* `if (auto it = m.find(key); it != m.end()) cout << it->second;`, также работает в ветке else.
  * Полезно для `dynamic_cast`
  * Полезно для `find()`

# Как объявлять константы [00:13]
* Если в `.cpp` или `.h`, не внутри классов:
  * Но ещё лучше с `constexpr`: https://github.com/isocpp/CppCoreGuidelines/blob/master/CppCoreGuidelines.md#Rconst-constexpr
    * Это не форсирует вычисление в compile-time, но проверяет, что оно возможно, запрещает проблемы с порядком инициализации.
  * `constexpr` не прокатит с `std::string`:
    * Можно просто `const`, означает "осторожно с порядком инициализации", он не определён между TU, было в начале года.
  * `const`, в отличие от переменных, имеют internal linkage и не торчат наружу.
    * Но адрес, разумеется, будет отличаться в разных единицах трансляции.
* Как объявлять статические константы-члены классов
  * Уже не internal linkage, а всегда external linkage.
  * Обязаны определить ровно один раз (ODR), как и любую функцию, но инициализатор
    можем писать как в объявлении (если хотим использовать как размер массива),
    так и в определении.
  * Компилятор иногда может не требовать определение даже по стандарту, но лучше не надо 
    экспериментировать (а то ill-formed, no diagnostics required).
    * Очень вероятно потребует, если брать адрес от константы:
      `static constexpr SIGNATURE[] = "HUFF";`
  * Идеальный способ: `static inline constexpr` (с C++17).
    Слово `inline` работает как для `inline`-функций: добавляет определения везде и
    требуется, чтобы они совпадали прямо по токенам.
    * Линковщик, скорее всего, выберет одно определение.
    * На самом деле для `static constexpr` слово `inline` автоматически, но давайте правила попроще.
* Резюме:
  * Всегда `constexpr`, если очень хорошо понимаете, что делаете и зачем — `const` ("сэкономить пару байт" не аргумент, имхо).
  * В заголовках всегда `inline` (как и функции): https://abseil.io/tips/168

# Structured binding и tuple [00:25]
## `std::tuple` [00:05]
https://en.cppreference.com/w/cpp/utility/tuple

* `tuple` и `make_tuple` для хранения элементов.
  * Гетерогенный список, пригодится в метапрограммировании, вроде `std::apply(fn, args)`, но про это потом.
  * Мне больше нравится `make_tuple`, потому что `tuple` может также означать копирование.
  * Можно даже делать `tuple_cat`
  * `tuple<A, B>` умеет понимать `pair<A, B>`
* `get<i>`, `tuple_size`
  * Нет циклов по `tuple`, это будет в метапрограммировании.
* Можно хранить ссылки, как и в `pair`.
  * Этим пользуется `std::tie`, который под капотом создаёт `tuple<>` из ссылок, который при присваивании вызывает `=` на элементах, получаем присваивание.
  * Но с этим много эффектов, аккуратно не сейчас.

## Structured binding [00:20]
https://en.cppreference.com/w/cpp/language/structured_binding

Мотивация:

* `[const/static/...] auto [a, b, c] = expr;` (также можно `]{...}` и `](...)`.
* Нельзя вложенно.
* Происходит на этапе компиляции: можно с массивами, но не с векторами.
* Удобно итерироваться по `map`.
* Удобно получать значения `pair` из `.insert`.

Как работает:

* Объявляем переменную, как если бы вместо `[a, b, c]` стояло некоторое уникальное `e`.
  * Тонкость: если `expr` — массив известного размера, то `e` сделаем такого же размера
    и скопируем элементы (copy-init для `=`, direct-init для `{}` и `()`).
  * Тип `e` обозначим `E` (без ссылок).
* Дальше привязываем элементы. Если массив, то каждый элемент — синоним для `e[0]`, `e[2]`...
* Если не массив, то пробуем как будто `tuple`:
  * Количество элементов должно совпадать с `std::tuple_size<E>::value`.
  * Дальше объявляем каждый элемент типа "ссылка на `std::tuple_element<i, E>::type`"
    * `i` — это исходно `std::size_t`.
    * ЗАБИТЬ: ссылка — либо lvalue, либо rvalue, в зависимости от инициализации
  * Инициализируем ссылку первым подходящим:
    * `e.get<i>()`
    * `get<i>(e)`
    * ЗАБИТЬ: здесь `e` делает perfect forwarding: если было lvalue (`auto&`), то остаётся lvalue.
              Иначе xvalue. Обычно нам пофиг, потому что всё равно везде ссылки.
    * Если попытаетесь сделать такое сами, то осторожно: 
  * Время жизни такое же, как и у `e`
* Иначе пробуем привязаться ко всем(!) нестатическим полям.
  Они должны быть доступны. Причём все поля должны лежать в одном классе
  (либо в нас, либо в ровно одном предке).

Примеры:

* В зависимости от `auto`/`auto&`/`const auto&` и инициализатора у нас получаются немного разные типы.
  * `auto` всегда скопирует объект целиком, а не просто его кусочки.
  * `auto&` попробует привязать ссылку, но не продлит жизнь временному объекту (не скомпилируется).
  * `const auto&` продлит жизнь временному объекту.
* `minmax`/`min`/`max` возвращают ссылки, из-за этого structured binding ломается: https://stackoverflow.com/a/51503253/767632

# RTTI [00:15]
Что такое RTTI?

* Компилятор сохраняет Run-Time Type Information на этапе компиляции.
* Для полиморфных типов (у которых хотя бы одна виртуальная функция) сохраняем в объект
  указатель на RTTI. Можно в таблицу виртуальных функций, а можно и по-другому.
* `dynamic_cast` смотрит на самом деле на RTTI и понимает по нему.

Второй способ получить RTTI в языке: `typeid(..)`

* Оператор возвращет `const type_info&` (некопируемый и неперемещаемый тип).
* У него можно спросить `==` и `!=`
* Можно спросить `name()`, получить белиберду
  * Может совпадать у разных типов, отличаться от запуска к запуску...
  * Можно расшифровать при помощи `boost::core::demangle` (иногда работает).
    * Пример кода
    * `sudo apt install libboost-all-dev`
* Чтобы можно было складывать в контейнеры, есть `std::type_index`,
  его уже можно копировать, сравнивать, класть в контейнеры
  * Не зависит от `name()`, использует `type_info::hash_code` и `type_info::before`
  * Можно написать свой, но незачем
* При этом ничего про тип узнать нельзя. Reflection отсутствует. Поля не перечислить.

Тонкости `typeid`

* От типа возвращает `const type_info&` на этапе компиляции
* От неполиморфного выражения не вычисляет его, а возвращает `const type_info&` на этапе компиляции (пример!)
* От полиморфного: вычисляет, возвращает `const type_info&` (если `nullptr`, то кидает `std::bad_typeid`).

Надо ли?

* Type erasure: не `void*`, а `std::any`.
  * Теперь можно копировать.
  * Теперь можно в рантайме проверять, что ничего не продолбали
* Исторически стоит дорого => редко используется => бывают баги и занимает много места
  * Во встраиваемом программировании отрубается `-fno-rtti`
  * Можно реализовать самому как библиотеку: Boost.TypeIndex

# Прочие ссылки, не на экзамен [00:05]
* User defined literals, не на экзамен: https://en.cppreference.com/w/cpp/language/user_literal
  * Пример из chrono: `auto duration = 10s` (секунд).
  * Пример для автовывода типов: `split(....) == vector{"foo"sv}` (иначе был бы `vector<char*>`).
  * Можно писать свои, можно даже парсить длинные числа руками.
* Был `dynamic_cast`. А для `shared_ptr` есть аналогичный `dynamic_pointer_cast` (и ещё три аналогичных `*_pointer_cast`).
  Это популярно для умных указателей, если вообще имеет смысл менять тип указателя, не меняя тип владения
  (для `unique_ptr` не имеет).
* CRTP:
  * https://en.wikibooks.org/wiki/More_C%2B%2B_Idioms/Curiously_Recurring_Template_Pattern
  * Можно реализовать для реализации `struct Point : operators<Point> { bool operator<(..); }`
  * Можно для вынесения любой другой функциональности в общего предка без виртуальных функций.
* Pimpl для выноса приватных полей и методов из заголовка и сохранения API/ABI. Ценой динамических выделений памяти.

# Unqualified functions lookup, Argument-Dependent Lookup (ADL), Koenig search [00:20???]
## Базовое про ADL [00:05]
http://www.gotw.ca/gotw/030.htm
https://stackoverflow.com/a/8111750/767632

* Пусть объявили класс в namespace и `operator<<`.
  Раз это функция, то почему её можно вызывать без `my_namespace::`?
  * Чтобы удобно было
  * Есть специальный механизм в языке: ADL, argument-dependent lookup.
  * Определение: если видим неквалифицированный вызов функции, то смотрим на типы
    аргументов и ищем функции во всех связанных namespace'ах.
* Более крутая идея: если мы вместе с классом дали пользователю какую-то функцию,
  то она должна иметь те же моральные права, что и класс.
  * http://www.gotw.ca/publications/mill02.htm
  * Пример: `begin()` и `end()` для range-based-for (тут можно только ADL, потому что мало ли где range-based-for используется).
  * Пример: `get<>()` для structured binding (тоже только ADL).
  * Пример: `copy_file(from, to)` из Filesystem library, ей не нужен доступ к приватным полям.
  * Пример: `swap()` для обмена содержимым.

## Тонкости и примеры ADL [00:10]
* Через ADL смотрим только на namespace типа, не рекурсивно вверх.
* Добавляем это к нашему обычному неквалифицированному поиску, возможны неоднозначности.
* Все type aliases (`typedef`, `using`) полностью разворачиваются, и только после этого смотрим на namespaces.
* Вложенные в тип аргумента типы тоже вызывают ADL (шаблонные параметры, функции).
* Вызовы конструкторов за функции не считаются. TODO: в смысле, имена-то мешаются.
* Hidden friends: объявили друга внутри класса, и теперь его достать только через ADL. Даже определить можно там же (кстати, inline врубится).
  * https://isocpp.org/blog/2020/03/Friends-and-where-to-find-them
  * https://www.justsoftwaresolutions.co.uk/cplusplus/hidden-friends.html
  * TODO: зачем?
* Есть тонкости с вызовом шаблонов с явными параметрами, они иногда не компилируются: https://stackoverflow.com/a/45493969/767632

# Как работает ADL [00:10]
TODO: надо ли?

https://abseil.io/tips/49
https://en.cppreference.com/w/cpp/language/adl

* Сначала поискали все имена функций в нужных namespace'ах.
  * Пошли от текущего scope наверх, пока не нашли кого-то с нужным именем. Включая `using`.
    Там остановились, выше не идём.
    Это первый namespace, в котором ищем.
    * Если нашли в этом namespace кого-то из трёх, то останавливаемся и ADL не включаем:
      * либо член класса (метод, поле, статическая функция или переменная)
      * либо объявление функции block-scope(!) не через using
      * либо кого-то левого (не функцию) с таким же именем
  * Дополнительно сделали ADL: добавили все type-associated namespace для каждого аргумента.
    * Сначала ищем все типы, связанные с `T` (точный список не на экзамен, но надо знать, что он непустой):
      * Сам тип `T`.
      * Все родители и прародители `T`.
      * Класс `U`, в котором лежит `T` (самый верхний, уже лежащий в namespace).
      * Рекурсивно запустились от шаблонных параметров.
      * Если указатель или массив — пошли рекурсивно.
    * Каждый тип (кроме `int`, `double`, ...) лежит в каком-то namespace.
      * Взяли ровно этот namespace.
      * При этом type aliases полностью разворачиваются.
* Теперь в каждом найденном namespace посмотрели на все функции с таким именем (включая `using`'и, но не включая `using namespace`).
  Выбрали перегрузку среди найденных.

## Практические следствия ADL
TODO

* Все вспомогательные функции определяйте строго в том же namespace, что и класс:
  * https://github.com/isocpp/CppCoreGuidelines/blob/master/CppCoreGuidelines.md#c5-place-helper-functions-in-the-same-namespace-as-the-class-they-support
  * https://github.com/isocpp/CppCoreGuidelines/blob/master/CppCoreGuidelines.md#c168-define-overloaded-operators-in-the-namespace-of-their-operands
* `namespace no_adl`+`using` для отключения случайного ADL?
  * Вызов конструктора не находится через ADL (и слава богу, теперь namespace no_adl работает и не конфликтует с классами)
* Как писать `std::swap` и почему: https://stackoverflow.com/a/5695855
* `count(vec.begin(), vec.end())` может скомпилироваться или нет в зависимости от того,
  указатели там или вложенные классы.
  Лучше `std::count`.
* Осторожно с передвиганием функций и типов в другие namespaces при рефакторинге.
