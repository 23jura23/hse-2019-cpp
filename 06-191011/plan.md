# Разбор теста [00:30]
* Важны формулировки вопросов и ответов, иначе ответ не про то:
  * "Что произойдёт" — "программы выведет то-то и то-то", "undefined behavior"
  * "Зачем нужно разделение на компиляцию и линковку" — "так может работать быстрее", а не "линковка делает то-то, а компиляция то-то"
  * Отделяйте `'\0'` и `'0'`
  * Если сказано "написать код" — нужен __полный__ и точный код, со всеми именами и точками с запятой.
    Иначе не отличить: не знаете или знаете, но забили писать.
* Очень важно понимать, что произойдёт undefined behavior, а не просто "выход за границы массива".
  Потому что в других языках "выход за границы массива" — это понятное событие.
* Разбор каждого задания.

## Представление отрицательных чисел в дополнительном коде

# Библиотеки [00:10]
* Зачем ещё могут быть нужны указатели на функции? Динамические библиотеки или даже плагины.
* Можно взять произвольный файл `*.so` (Linux) или `*.dll` под Windows,
  загрузить в память, попросить указатель на функцию с нужным именем, вызвать.
* Ещё это иногда поддерживается на уровне языка: объявляем функцию, говорим,
  что она будет в такой-то динамической библиотеке, а ОС (загрузчик)
  сам всё загрузит и нам даст нужные указатели.
  Подменили файл, перезапустили программу — ура, новая версия библиотеки.
* Ещё бывают статические библиотеки: `*.a`, `*.lib`, они вкомпилируются
  в исполняемый файл.
  Почти ничем не отличаются от объектных файлов.
* В любом нормальном языке очень важны библиотеки, их очень много.
  В 2019 году можно гуглить "Awesome C++ github" и находить списки __модных__ (необязательно самых хороших).

## Чтение и запись текстовых файлов [00:05]
### `printf` [00:10]
* Спецификаторы в `printf`, ширина, `%02d`, `%%`.
* `printf("%s", s)` против `printf("%s")` для случев `char *s` и `s = "Hello"`.

### `sprintf` и `snprintf` [00:08]
* Безопасный размер буфера
* Возвращает количество записанных символов (как и `printf`)

### `scanf` [00:22]
* Нужны точные спецификаторы, в отличие от `printf`.
* `scanf("%239s")`
* Игнорирование пробелов всеми, кроме `%c`
* Склеивание пробелов
* `%[`
* `fscanf` возвращет количество прочитанных элементов.
  По-хорошему надо всегда проверять.
  ```
  int h, m;
  assert(fscanf(f, "%d:%d", &h, &m) == 2);  // 11:30
  assert(fprintf(f, "%02d:%02d", h, m) == 5); // Количество записанных символов.
  ```
### `feof` не работает [00:05]

## Чтение и запись бинарных файлов [00:05]
* Обычно `fread` и `fwrite`:
  ```
  int array[100];
  assert(fread(array, sizeof(int), 100, fin) == 100);
  assert(fwrite(array, sizeof(int), 100, fout) == 100);
  ```
  Зачем разделять размер одного элемента массива и количество элементов?
  Код чуть-чуть удобнее.
  Но вообще каждая функция может записать/прочитать лишь часть элемента.
* Эти ребята плохо работают между системами: выравнивание структур, разный размер
  под разными системами, порядок байт внутри `int`...

## Прочие функции стандартной библиотеки [00:10]
* `time`
* `srand`, `rand`, `srand(time(NULL))`
* `qsort`
* `system`
* `strcpy`, `strncpy` (обе небезопасны почему-то)
* `memcpy`, `memmove`
* `strtok`
