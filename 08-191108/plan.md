# Классы [00:25]
## Напоминание и основы [00:15]
`array` в Си и провести параллель с `Array` в C++ (название отличается от последней лекции, чтобы отличалось от структуры).

```
struct Array {
    int *data;
    size_t len;
    Array(size_t len) {
        data = new[len];
        len = len;  // WTF??? Это место для this или для init_len.
    }
    ~Array() {
        delete[] data;
    }
    int get(int id) {
        return data[id];
    }
    void set(int id, int value) {
        data[id] = value;
    }
};
```

* Терминология:
  ```
  int num;
  Array arr(10);
  ```
  * `int`, `Array` — тип переменной
  * `num`, `arr` — Имя переменной
  * `Array` — класс
  * `arr` — объект/экземпляр класса
  * Внутри класса: поле, метод, конструктор, деструктор.
* Доступ к полям и методам внутри методов просто так, как к глобальным переменным.
* Ещё есть слово `this`, которое указывает на текущий объект.
  Можно `this->data()`, если есть локальная/глобальная переменная (особенно в конструкторах, см. `len`).
  Если сделаем `swap`, то можно `this->swap(other)`, чтобы не вызвать случайно глобальную функцию.
* На самом деле это просто скрытый параметр у методов (implicit object parameter), он первый.
  И он тоже участвует в перегрузке: бывает константный и неконстантный.
  ```
  const Array arr(10);
  arr.get(10); // oops? Надо const-qualifier у метода.
  ```

## Приватные и публичные поля и методы [00:10]
* По умолчанию к полям можно обратиться и снаружи:
  ```
  Array arr;
  arr.len++;  // WTF
  ```
* Можно добавить `private:`/`public:`, чтобы сделать поле или метод "приватным".
  Проверяется на этапе компиляции, больше ни на что не влияет.
* Слово `class` в C++: в начале написан `private:`, а не `public:`.

# Время жизни объекта [00:35]
## Объекты и подобъекты [00:10]
* Время жизни объекта: в какой-то момент создаётся (конструктор), потом живёт и на нём можно вызывать методы/менять поля, потом умирает (деструктор).
  Это прям термины из стандарта, вызывать методы на мёртвом объекте нельзя.
  Память выделяется строго до создания (стэк/куча), освобождается строго после смерти.
  Но связывать необязательно, `vector<int>` отдельно делает память, отдельно создаёт объекты.
* `new`: одновременно создаёт память и инициализирует. Можно разделить.
* `delete`: одновременно удаляет объект и освобождает память. Можно разделить.
* `new[]` и `delete[]` инициализируют/удаляют массивы объектов.
* Пусть есть сложные поля:
  ```
  class BufferedFileReader {
      FileReader reader;
      Buffer buffer;
      ...
  };
  ```
  Тут важно, что `buffer` иниализируется после `reader`.
* Конструктор обязан инициализировать все поля. Поэтому это автоматически делает за нас язык.
  Но можно и руками (member initializer list):
  ```
      BufferedFileReader(const char *file) : reader(file), buffer(reader) {}
  ```
* А деструктор обязан все деинициализировать.
  Желательно в порядке, обратном созданию.
  Причём в фиксированном порядке, потому что неизвестно, какой конструктор вызывался.
* Вывод: надо фиксировать порядок инициализации.
  Договорились: в порядке объявления. Напишите в member initializer list другое, получите warning.
* Деструктор есть всегда.
* Конструктор по умолчанию генерируется автоматически, если не создали какой-нибудь свой.

## Тонкости инициализации [00:10]
```
struct Foo {
    Foo() {}
    int a;
    vector<int> b;
    int &c;
    int d[10];
};
```
* "Default initialization": `new T`, `new T[10]`, `T a;`, `T a[10];`, объявили поле и не указали в member initializer list.
  * Для неклассов: не инициализируется. В частности, `new int[10]` не заполняет нулями.
  * Для классов: конструктор по умолчанию.
  * Для ссылок: ошибка.
* "Value initialization": `new T()`, `new T[10]()`, объявили поле и указали `a()` в member initialization list.
  * Для `int`: cначала заполнили всё нулями, потом default initialization.
  * Для классов просто default initialization. Технически там при отсутствии автоматически сгенерированного конструктора по умолчанию
    будет zero+default, но лучше про это не думать.
* "Direct initialization": добавили параметры конструктора: `new T(10, 20)`, `new T[10](20, 30)`, `T a(20, 30)`.
* The most vexing parse: `Foo f();`.

## Copy assignment [00:10]
* Оператор присваивания: отдельный метод. По умолчанию копируются поля.
  * Чем плохо: скопировали указатель, double-free, упс.
* Надо писать свой:
  ```
  Array& operator=(const Array &other) { // Секрет, сначала с void
      if (&a == this) return *this; // Секрет, это для a == a и оптимизации.
      delete[] data;
      data = new int[other.len];
      len = other.len;
      for (int i = 0; i < len; i++)
          data[i] = other.data[i];
      return *this; // Секрет, это для a = b = c
  }
  ```
  * Тут надо очень осторожно из-за `a = a`, про это часто забывают.
    Пример: `a = min(a, b);`
  * Ещё конвенция: чтобы можно было писать `a = b = c`, оно же `a = (b = c)`.

## Copy initialization [00:10]
* `operator=` не вызывается при `Array c = d`, никогда.
* `Array(const Array&)`, смотрит на конструкторы с одним параметром.
* copy initialization: `Array c = d;` (это именно инициализация), при вызове функции, при возврате значения.
