# Обработка ошибок [00:15]
http://joeduffyblog.com/2016/02/07/the-error-model/

## Два вида ошибок [00:05]
1. Ошибки программирования: любой UB, нарушение инварианта (двоичный поиск, состояние класса),
  нарушения контракта.
  ```
  void foo(const char *s) {
      printf("%s\n", s);  // Некорректный s.
  }
  ```
  * Лучше выявлять на стадии тестирования.
  * Обычно видны не сразу, а через какое-то время.
  * Можно пробовать проверять и детектировать (например, `vector::at` вместо `vector::operator[]`),
    но не задетектирует всё (потому что баги) и неясно, что делать после обнаружения
    (мало в чём можно быть уверенным).
  * Если случилось, то никаких гарантий, all bets are off.
    Баг в программе точно есть, причём неизвестный, могло упасть где угодно.
1. "Ошибки окружения": некорректный ввод пользователя, файл не найден,
   оборвалось сетевое соединение...
  * Могут произойти независимо от программы.
  * Лучше обрабатывать.
  * Например, клиент Telegram должен быстро работать, даже если
    сервер внезапно отвалился.
    Переподключиться? Держать ещё одно соединение в запасе? Надо думать.
  * Не хватило прав доступа — может, наоборот, не сообщать пользователю,
    зато сообщить администратору.

## Надо думать [00:05]
Бывают пограничные ситуации в разных контекстах.

* На хороших контестах гарантируется, что ввод корректен.
* А что если кончился стэк/память/место на диске?
  * Место на диске: можно забить, можно почистить свой собственный кэш.
  * Память: а если при обработке потребуется ещё память?
  * Не удалась запись в файл: могут быть разные требования к чат-клиенту (который
    может всё скачать с сервера) и самому серверу (которому надо как-то
    восстанавливаться и централизованно сообщать "жёсткий диск сломался").
* Нарушен инвариант структуры — проблема.
  А вот если мы её перед этим считывали по сети, то, может, это попытка взлома
  и надо залогировать и пропустить запрос.

Про каждую ошибку в программе надо думать:

1. Что случится, когда произойдёт? (не "если")
1. Можно ли с ней сделать что-то разумное?

## Обработка ошибок [00:05]
Почти всегда можно залогировать ошибку _для разработчика_.

1. Уронить процесс целиком.
   Самое безопасное при ошибках программирования.
   Хотя тоже может нарушить инварианты (например, файл не до конца записали).
   Можно ещё перед этим позвонить домой и отправить багрепорт.
   А потом немедленно упасть, даже если кажется, что всё хорошо.
1. Уронить кусок процесса.
   Только если не ошибка программирования (хотя в Java/Python с изоляцией получше).
   Например, мы сервер и порвалось соединение с клиентом.
1. Как-то обработать: например, попробовать другой адрес для подключения к серверу.
1. Сообщить пользователю и попросить что-нибудь сделать: "файл не найден, выберите другой".
   * Важно понимать, что пользователь далеко не всегда что-то может сделать.
     О каких ошибках и как сообщать пользователю — отдельный вопрос.

Проще и надёжнее всего уронить программу целиком.

Нет серебрянной пули для обработки ошибок: это такая же часть спецификации
программы, над которой надо хорошо думать заранее и отдельно реализовывать.

Например, `On Error Resume Next` писать не надо никогда.

# Инструменты для обработки ошибок [00:15]
## C-style, глобальная переменная и возвращаемое значение [00:05]
```
void read_people() {
    FILE *f = fopen(filename "r");
    if (!f) {  // Не удалось открыть файл — вернули nullptr.
        printf("Unable to open file\n");
        return;
    }
    // ...
    fclose(f);
}
```

Можно попробовать разобраться поподробнее:

* `EAССES` — не хватило _каких-то_ прав доступа (на файл, на папку выше, на создание файла в режиме `w`...).
  Самое популярное. Пользователю придётся проверять все папки в иерархии, права процесса...
* `EISDIR` — попытались открыть папку как файл на запись.

Пример под Linux: `int chdir(const char *path)`.
Возвращает 0 или -1, а дальше смотрим в глобальном `errno` код.

Разумеется, так нельзя вызывать несколько функций подряд (потому что `errno` затёрлось)
и плохо работать с многопоточностью (надо заводить `errno` на поток).

Бывают костыли вроде `perror` (вывести на экран последнюю ошибку).

## C-style, код ошибки [00:05]
```
int sqlite3_open(
  const char *filename,   /* Database filename (UTF-8) */
  sqlite3 **ppDb          /* OUT: SQLite db handle */
);
```

Функция сразу возвращает код ошибки.
А возвращаемое значение пишет по указателю.

Всё ещё надо проверять и не очень удобно.

## Можно возвращать много информации [00:05]
Так делают в Go, Rust и Haskell (очень много сахара!):
```
fn read_people() -> Result<People, String> {
    match open() {
        Ok(f) => {
           ...
        }
        Err(err) => return Err(err) /* не умеет обрабатывать, сообщаем наверх */
    }
}
```
и добавить сахара:
```
fn read_people() -> Result<People, String> {
    let f = try!(open());
    ...
}
```

Всё ещё явно видно, где могут быть ошибки (и при вызове, и при реализации), но не надо писать кучу кода.
А ещё можно отдельных механизм (паники) для необрабатываемых ошибок.

В Haskell можно свои комбинаторы завести.

# Обработка ошибок в C++ [00:25]
## Исключения [00:10]
Призваны решить следующие проблемы кодов возврата:

1. Захламляется код, даже если мы не умеем обрабатывать ошибку.
1. Перемешаны happy path/sad path.

Идея:
* В месте возникновения "кидаем" исключение `throw`:
* В промежуточных функциях ничего не делаем
* Там, где понимаем, что можно сделать, ловим и обрабатываем.

```
struct invalid_vector_format {};
std::vector<int> readVector() {
    int n;
    if (!(cin >> n)) {
        throw invalid_vector_format();
    }
    std::vector<int> result(n); // может кинуть исключение.
    for (int i = 0; i < n; i++) {
        if (!(cin >> result[i])) {
            throw invalid_vector_format(); // кинул исключение, знаем, что кто-нибудь поймает.
        }
    }
    return result;
}
void solve() {
    std::vector<int> a = readVector();
    std::vector<int> b = readVector();  // исключение пролетело насквозь
    // вычисления
    writeAnswer(answer);
}
int main() {
    try {
        char *x = malloc(10);
        solve(); // исключение пролетело насквозь
        free(x);
    } catch (invalid_vector_format &err) {
        printf("Invalid vector format: %s\n", err.what());
    }
}
```

Теперь у нас промежуточные функции могут меньше думать про ошибки.
Это особенно удобно, когда ошибку можем обработать только на самом верхнем уровне.

## Ресурсы, stack unwinding [00:05]
Тут надо аккуратно уничтожить все векторы.
Язык это и сделает: при выходе из блока (в т.ч. функции) уничтожает все локальные переменные.
Это называется "раскрутка стэка" (stack unwinding).

При этом `char *x` утечёт, как обычно.
Мораль: используйте деструкторы, как в `std::vector`.
Или надо ловить вообще все исключения, а потом аккуратно разбираться, кого надо почистить, это неприятно.

## Исключения из конструкторов, RAII [00:05]
Если кончилась память в момент выделения вектора,
вылетит стандартное исключение `std::bad_alloc`.

И вектор нельзя будет использовать.
Даже синтаксически:
```
try {
    std::vector<int> a(1000000);
    ...
} catch (std::bad_alloc&) {
    ...
}
```
Наконец, расшифровка RAII: resource acquisition is initialization.
Конструктор должен полностью проинициализировать класс и убедиться во всех инвариантах.
А если не смог — кидаем исключение.

## Непойманные исключения [00:02]
Если исключение не поймать, вызовется `std::terminate`, что аварийно завершит программу.

Причём implementation-defined, будет ли перед этим раскрутка стэка вплоть до `main`.

## Слухи [00:03]
* `assert` вообще не про исключения и может быть убран компилятором, не надо его использовать.
  Это чисто отладочная вещь.

# Использование исключений в C++ [00:15]
## Несколько типов исключений [00:10]
* UB и деление на ноль не кидают ничего.
  В Java есть специальный `NullPointerException` и `ArithmeticException`, но что с ними делать — вообще неясно.
* `std::exception` — базовый класс для всех _из STL_ (обычно свои тоже к нему приписывают).
  Реализует `virtual const char *what() const`.
  * `std::logic_error` — условно "ошибки программиста".
    Здесь `std::invalid_argument`, `std::out_of_range` и ещё.
  * `std::runtime_error` — условно "ошибки окружения".
    Есть наследник `std::system_error`, а у него наследник `ios_base::failure`
    (ошибки ввода-вывода).
* `new Foo()` кидает `std::bad_alloc`, если не удалось выделить память. Но что с ним делать?
* `vector::at` кидает `std::out_of_range`. Но что с ним делать?
* `std::stoi` кидает `std::invalid_argument` (не число) или `std::out_of_range` (число не влезет).
* `<iostream>` не кидает по умолчанию (надо проверять флаги), но можно включить режим.

Можно добавлять свои классы, а дальше ловить:

```
struct Foo {};
struct Bar : Foo {};
...
try {
} catch (Bar &err) {
} catch (Foo &err) {
} catch (std::exception &e) {
}
```

* `catch (...)`
  Ловит исключения любого типа, проанализировать текущее нельзя.
  Но можно перекинуть: `throw;` (работает в любом блоке).
  Всё ещё не ловит деление на ноль и прочие UB!

## Вложенные try/catch [00:03]
```
try {
    // вызвали функцию, в которой
    try {
        throw Bar();
    } catch (Foo &err) {
    }
} catch (Bar &err) {
}
```
Проверяется от внутренних к внешним (в том числе сквозь стэк) и в каждом `try`
пробуем за'bind'ить сверху вниз.

Если внутри catch исключение, то оно вылетает во внешний try.

## Как используют [00:02]
* Ловят всегда по ссылке, потому что активно используется иерархия и мы не хотим слайсинг.
  Синтаксис в `catch` — просто инициализация (как переменная/параметр).
* Кидают объекты из отдельной иерархии (чтобы можно быть ловить по типу однозначно),
  причём выделенные "на стеке" (не в куче).
* Исключения конкретно в C++ предназначены для обработки _исключительных_ ситуаций,
  которые возникают редко.
  Компилиторы оптимизируются под happy path, а переключение на sad path может очень сильно тормозить.

# Гарантии исключений [00:15]
Чтобы что-то доказывать про корректность кода,
надо формализовать, что он делает в случае исключений.

* No throw: исключения не кидаются, код всегда работает (или в хлам роняет программу, если не повезло).
  * Хороший пример: `a = b;` для простых типов.
  * Плохой пример: то же самое для сложных (в случае вектора может
    не хватить памяти).
  * Плохой пример: ввод-вывод.
* Strong guarantee (сильная гарантия): если исключение и вылетело, то ничего не поменялось.
  * Пример: `list::push_back`.
    Если памяти не хватило, то исключение вылетело, но список не поменялся вообще.
    Если упал конструктор копирования, то список не поменялся вообще.
  * Пример: `vector::push_back`.
    Если памяти не хватило, то исключение вылетело, но вектор не поменялся вообще.
    Тонкость: для этого надо, чтобы элементы могли копироваться с гарантирей strong.
    Или перемещаться, но тогда nothrow (это мы ещё не изучали).
* Basic guarantee (базовая гарантия): если исключение и вылетело, то не произошло UB,
  все объекты в _каком-то_ корректном состоянии (инварианты есть), нет утечек и прочих проблем.
  * Пример: `vector::push_back`, если мы не имеем права копировать/перемещать объекты без ошибок.
    Правда, всё ещё надо уметь уничтожать объекты.
* No guarantee: если исключение произошло, можно только завершить процесс.

Надо везде делать basic guarantee как минимум.
STL делает.

В идеале — strong guarantee, но это может быть сложно или невозможно без
замедления кода (потому что нельзя удалять старые данные, пока новые не создались).
