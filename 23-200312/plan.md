Не надо писать `try { /* ... */ } catch (...) { throw; }`.

Тонкость: строгих гарантий `erase`, `insert`, `emplace` для `vector`/`deque` дают не всегда.
Но стараются. Надо читать для точность.

Для ассоциативных контейнеров тоже не факт.

Можно инициализировать через brace-init (как массивы), даже map.

value_type у контейнера и итератора

## Инвалидация
Задача: перед каждым чётным элементом вектор вставить 0
```
for (vector<int>::iterator it = v.begin(); it != v.end(); ++it) {
    if (*it % 2 == 0) {
        v.insert(it, 0);  // Упс: инвалидация итератора, надо возвращаемое значение `insert`.
    }
}
```

Задача: удалить все чётные числа:
```
for (vector<int>::iterator it = v.begin(); it != v.end(); ++it) {
    if (*it % 2 == 0) {
        v.erase(it, 0);  // Упс: инвалидация итератора, нельзя делать ++, надо возвращаемое значение (с C++17, до этого момента надо erase(it++)).
    }
}
```



## list
* Двусвязный список, удаление всегда за линию от количества элементов.
* Нельзя random access, итераторы и указатели не инвалидируются.
  Можно идти с начала, можно идти с конца за константу.
* Можно перемещать элементы из одного списка в другой:
  * `splice(pos, x)` (если `x != this`): утащили все элементы из `x` (это контейнер или итератор из одного элемента) в позицию `pos`.
    Итераторы и ссылки тоже переехали.
    Всё за константу.
  * `splice(pos, begin, end)`: перетащили внутри себя элементы за константу на другое место.
    А если это был другой список, то линия (потому что надо пересчитать `size`; до C++11 было по-другому).
* Есть `remove`, `remove_if`, `unique`, `merge`, `reverse`, стабильный `sort`: аналогично алгоритмам, но не инвалидируют.

## forward_list
* Односвязный список, детально не разбираем.
* Куча проблем с тем, что нельзя просто взять и сделать `insert`, надо `insert_after`.
  Свои методы в больших количествах.

## string
TODO

rope, не гарантируется последовательная память
c_str() и data()
substr (индексы)
find (индексы)
append, +, +=
basic_string
wstring == `basic_string<wchar_t>`
можно даже traits для сравнений символов

## Адаптеры
stack, queue, priority_queue
bitset

## Ассоциативные контейнеры
* переупорядочивают элементы для быстрого поиска O(logN)
* возможные реализации: дерево поиска O(logN)
* set, map, multiset, multimap; отличия
* Требуют отношение порядка: для элементов должен быть определен \texttt{operator<(...)}
* Нет произвольного доступа по индексу

Требуют порядка на элементах

Методы по сравнению с обычными контейнерами: сравнение, erase по key, insert с подсказкой, count, find

TODO: Что возвращает insert/emplace

Нельзя менять добавленные элементы (`value_type = const Key` для `set`).

`operator[]` всегда создаёт элемент
свой функтор-компаратор, без состояния и с состоянием. Осторожно с трёмя свойствами (антирефлексивность, например).
value_type = `pair<const Key, Value>`
range-based for со structural binding.

внутренний метод `lower_bound`/`equal_range` (внешний можно или нельзя?)
`count` у `multiset`/`multimap` работает за линию.

`emplace` вместо `insert(make_pair(...))`/`insert(pair(...))`

напоминание: как стирать элементы по условию из `map`? Надо не увеличивать итератор удалённого элемента.

## Неупорядоченные ассоциативные контейнеры
для unordered свой хэш

## Алгоритмы
swap
iter_swap
max/min (есть версия с предикатом)
count, count_if

Если что-то не нашёл, то end
find, find_if
min_element, max_element
equal, mismatch
for_each
fill
generate
copy
reverse
sort
transform

Реализация алгоритма copy, copy_if
iterator_category
tag dispatching
Реализация advance
iterator traits для указателей
