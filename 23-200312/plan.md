Не надо писать `try { /* ... */ } catch (...) { throw; }`.

Тонкость: строгих гарантий `erase`, `insert`, `emplace` для `vector`/`deque` дают не всегда.
Но стараются. Надо читать для точность.

Для ассоциативных контейнеров тоже не факт.

Можно инициализировать через brace-init (как массивы), даже map.

## list
* Двусвязный список, удаление всегда за линию от количества элементов.
* Нельзя random access, итераторы и указатели не инвалидируются.
  Можно идти с начала, можно идти с конца за константу.
* Можно перемещать элементы из одного списка в другой:
  * `splice(pos, x)` (если `x != this`): утащили все элементы из `x` (это контейнер или итератор из одного элемента) в позицию `pos`.
    Итераторы и ссылки тоже переехали.
    Всё за константу.
  * `splice(pos, begin, end)`: перетащили внутри себя элементы за константу на другое место.
    А если это был другой список, то линия (потому что надо пересчитать `size`; до C++11 было по-другому).
* Есть `remove`, `remove_if`, `unique`, `merge`, `reverse`, стабильный `sort`: аналогично алгоритмам, но не инвалидируют.

## forward_list
* Односвязный список, детально не разбираем.
* Куча проблем с тем, что нельзя просто взять и сделать `insert`, надо `insert_after`.
  Свои методы в больших количествах.

## string

## Адаптеры
