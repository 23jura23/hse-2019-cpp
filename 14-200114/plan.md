# Namespaces [00:35]
## Базовое [00:05]
* Зачем: в разных местах программы/библиотеках может хотеться называть функции, классы и переменные просто,
  и не волноваться и коллизиях.
  Например: пишем сервер, написали `class User`, который хранит пользователей на сайте.
  А ещё такой же класс может встретиться в какой-нибудь библиотеке для запросов к базе данных,
  только там один пользователь — это с каким паролем работать с базой данных.
* Можно использовать вложенные классы:
  ```
  class Database {
  public:
      class User { ... };
  };
  ```
  и дальше писать всё приложение внутри одного своего класса, чтобы не пересеклось
  с глобальными функциями/методами:
  ```
  class Application {
  public:
      class User { ... };
      static Database connectToDb() { ... }
      ...
  };
  ```
  Тогда `Database::User` и `Application::User` — разные классы и при компиляции, и при линковке.
  * Но тогда надо писать много слов `static` не по делу и в разных файлах использовать разные классы,
    либо заводить один God object, который содержит все функции и переменные со всех файлов.
  * Это не очень: надо будет завести заголовок и каждый раз всё перекомпилировать.
*  А можно сделать
  ```
  namespace database { // И в .h, и в .cpp
  class User { ... };
  } // namespace database // ; не нужна
  namespace server {
  class User { ... };
  database::Database connectToDb() { ... }
  } // namespace server
  ```
* Обычно на файл (.h, .cpp) есть один namespace, пишется без отступов.
* Традиционно имя в snake_case.
* `namespace`, в отличие от классов, можно "переоткрывать" сколько угодно раз в разных файлах.
* Теперь мы можем требовать от каждой библиотеки свой отдельный namespace, а внутри творит что хочет.
* Синтаксис для "заглядывания" внутрь `namespace` — `::`, как у классов.

## Using [00:05]
* Можно ещё в любом месте программы сказать:
  * `using database::Database;` (протащит в эту точку конкретное __имя__ — это важно для перегруженных функций)
  * `using namespace database;` (протащит в эту точку все имена из namespace)
  * Оба работают транзитивно по namespace и почти нельзя определить, где исходно было объявлено/определено имя
    (можно в ADL, см. ниже).
* Использовать `using namespace` в `.cpp` в целом можно, если у нас есть гарантии про то,
  какие имена лежат в namespace и мы их __все__ помним.
  * В случае `std` это неверно (мы не знаем, что может лежать в стандартной библиотеке), поэтому `using namespace std;` — нельзя.
* `using namespace` в `.h` можно, но не нужно, потому что `.h` может подключить кто угодно,
  кто уже надеялся, что имени нет.
  * А вдруг в `.h` внезапно добавим?
  * А вдруг цепочка вложенных `.h`?

## Вложенные, глобальные, анонимные [00:10]
* Можно вкладывать:
  ```
  namespace database {
      namespace internal {
          void foo();
          void bar();
          struct Foo {};
      } // namespace internal
      struct User {};
  } // namespace database
  namespace database::internal { // С C++11
     void foo();
     void bar();
  } // namespace database::internal
  ```
* Explicitly excluded: inline namespace
* Есть глобальный namespace, имени нет:
  ```
  int foo;
  namespace database::internal {
      int foo;
      void foo() {
          ::foo = 0;
      }
  }
  ```
* Есть спецсинтаксис `namespace { void foo(); void bar() }`, 
  который аналогичен `static void foo(); static void bar();`,
  включает internal linkage (запрещает видеть `foo`/`bar` за пределами единицы трансляции).
  * В `.cpp` осмысленен, в `.h` скорее нет.
  * После этого `static`-функции в плюсах не пишем.

## Правила qualified/unqualified lookup [00:15]
### Unqualified lookup
Если слева от имени чего угодно (функция, namespace, класс...) нет `::` — unqualified lookup.

* https://en.cppreference.com/w/cpp/language/unqualified_lookup
* Общее правило: пошли из текущих фигурных скобок наверх,
  причём обычно смотрим только на строчки выше текущей,
  но в классах можем смотреть на всё тело класса целиком.
  ```
  struct Foo {
      void foo() {
          a = a; // не ок
          x = 10; // ок
      }
      int x;
  } // 1
  Foo a;  // на уровне файла смотрим только ::Foo, перед этой строчкой
  namespace foo {
      Foo a; // смотрим ::foo::Foo, ::Foo
      namespace bar {
          Foo a; // смотрим ::foo::bar::Foo, ::foo::Foo, ::Foo, всё перед этой строчкой; найдём 1
      }
      namespace baz {
          struct Foo {} // 2
          Foo a; // смотрим ::foo::baz::Foo, ::foo::Foo, ::Foo; найдём 2
      }
      namespace bar {
          struct Foo {}; // 3
      }
  }
  ```
* Explicitly excluded: Definition outside of its namespace (объявили переменную внутри namespace, определили снаружи)
* В теле функций: сначала посмотрели на имена внутри функции, потом полезли
  в namespace снаружи определения (не объявления).
  Вы это уже знаете: там раньше был только глобальный `namespace`,
  теперь просто иногда выкидывается `bar`.
* В теле метода класса: смотрим на __все__ имена в классе, в родительских классах,
  в тех, куда мы вложены... (не просто на те, что до текущей строчки).
* Тонкости за кадром: параметры по умолчанию в объявлениях, `friend`-функции, статические переменные...

### Qualified lookup
Если слева от имени стоит `::` — qualified lookup.

* В `A::B::C` хотим понять, что есть `C`.
  Сначала нашли `A::B`, а потом внутри него нашли `C`.
  А чтобы найти `A::B`, сначала нашли `A`, а потом внутри него нашли `B`.
* "Внутри" — всякие `using` тоже считаются.
* "Нашли" — `A` ищется при помощи unqualified lookup.

### Проблемы с поиском
А вот в выражении `::foo::Foo` у нас все поиски qualified, начиная с самого верхнего.

Из-за этого могут быть стилистические проблемы (https://abseil.io/tips/130):
```
namespace database {
    namespace std {
    }
    ...
    std::vector<int> x; // oops
}
```
Поэтому рекомендация: namespace хороши, но не надо давать вложенным
имена, которые могут совпасть с именами, которые будут искаться при помощи unqualified.
А в `.h`-библиотеках лучше всегда писать `::std`, но это уточните у практиков.

Например, в Java такой проблемы нет: там либо полностью unqualified, либо ищется от корня.

# Стандартная библиотека C++ [00:45]
## Именование [00:05]
* В стандартной библиотеке C++ есть кусок под названием STL (standard template library),
  это всякие вектора и алгоритмы.
* Ввод-вывод (`iostream`) строго, кажется, туда не входит.
  Но иногда STL путается с "стандартная библиотека C++".
* Конвенция в стандартной библиотеке C++: заголовок пишется без `.h`
  и обычно добавляет имена только в `namespace std`
  * Добавили что-то своё в `namespace std` (за парой исключений) — UB
* Есть два вида заголовков из Си:
  * `<stdio.h>` — всё подключил в глобальный namespace, опционально в `std`
  * `<cstdio>` всё подключил в `std`, опционально в глобальный

## Ввод-вывод [00:10]
Есть набор классов для ввода-вывода.
Довольно общий, но местами, имхо, не очень удобный.

* Иерархия классов:
  ```
  std::ios -> std::istream, std::ostream -> std::iostream
  std::istream -> std::ifstream
  std::ostream -> std::ofstream
  std::iostream -> std::fstream, std::stringstream
  ```
  * Базовый `std::ios` определяет функции для обработки ошибок.
    Обычно вы про него не думаете.
  * В функциях, которые сохраняют/читают данные вы обычно
    берёте ссылку на `istream`/`ostream`.
  * В функциях, которые открывают/закрывают потоки/файлы,
    нужен конкретные `ifstream`/`ofstream`/`stringstream`.
  * Ещё вы можете увидеть всякие `basic_istream`, это обобщения
    на случай, если символ — не `char` (а например, четыре байта).
* Можно использовать глобальные `istream cin`, `ostream cout, cerr` из `<iostream>:
  ```
  int x;
  std::string y, z; // автоматически выделяется буфер нужного размера
  std::cin >> x >> y; // считали число, считали строку до пробельного символа
  std::cin.getline(z); // считали в z всё до перевода строки
  std::cout << x << "10" << "\n";
  std::cout << "foo" << std::endl; // endl ещё и буфер сбросит, это медленно.
  ```
* Можно открыть файл из `<fstream>`:
  ```
  std::ifstream in("a.txt"); // Если файл не открылся? Будет в состонии "ошибки", надо проверять
  // in.close() // Не нужно, даже если нет проверки на успешность.
  ```
* Можно объявить `std::stringstream s;` из `<sstream>`:
  ```
  std::stringstream s;
  s << 10 << " " << 20;
  std::string buf = s.str();
  std::string str10, str20;
  s >> str10 >> str20; // Чтение в std::string не требуе
  ```

## Как работают операторы и писать свои [00:10]
Это называется "formatted input/output"

```
std::ostream& operator<<(std::ostream& os, int v) {
    return os;
}
std::istream& operator>>(std::istream& is, int &v) {
    return is;
}
std::cin >> x >> y;
(std::cin >> x) >> y;
operator>>(operator>>(std::cin, x), y);
```

* Стандартная библиотека перегружает операторы для базовых типов
  (`int`, `double`, `char`, `char*`) и каких-то своих (`std::string`)
* В отличие от `printf`, тут нельзя ошибиться в формате и можно добавлять свои типы:
  ```
  struct BigInt {
  };
  std::ostream& operator<<(std::ostream& os, const BigInt &v) {
      return os << (int)v; // алгоритмический костыль
      return os << static_cast<int>(v); // C++-style алгоритмический костыль, про static_cast ещё потомо будет
  }
  ```
  * Важно писать:
    * Для базовых классов (`istream`, не `ifstream`)
    * По ссылке, неконстантной
    * Возвращать ссылку на свой левый параметр

## Побайтовый ввод-вывод [00:05]
Это называется "unformatted input/output".
Всё ещё есть отличие между текстовым и бинарным режимом: `std::ifstream f("a.bin", std::ios_base::in | std::ios_base::binary);`.

* `cin.get` — один символ, если не удалось — `istream::traits_type::eof()`
* `cin.peek` — один символ и не вытаскивать
* `cin.unget` — запихнуть символ обратно, с ним надо аккуратно читать документацию, когда это можно делать
* `read` — аналог `fread`, читает символы в буфер
* `seekg`/`tellg` — аналоги `fseek`/`ftell`, можно узнать позицию в файле.

## Обработка ошибок [00:05]
У каждого потока есть три бита состояния, которые можно узнать:

* `badbit` — поток умер: не смог записать байт (место кончилось)
* `failbit` — не удалось прочитать/записать, но поток жив.
  Например, неверный формат.
  Где мы сейчас в потоке — непонятно.
* `eofbit` — мы __уже__ знаем, что поток закончился (аналогично `feof`).
  Например, если в конце файла `123 ` и мы прочитали число, то мы не знаем, что за пробелом конец потока.

Чтение: `.rdstate()`, `.fail()`, `.eof()`, `.bad()`, `operator bool` (отрицание `fail`) и `operator!`.

Запись:
* `clear()` для сброса/перезаписи флагов.
* `setstate()` для __добавления__ флага.

* На контестах достаточно `while (cin >> n)`
* Для корректного чтения/записи `BigInt` стоит не просто читать символы,
  а ещё и флаги ставить при ошибках.
* Чтобы показать совсем разумную ошибку, обычно надо парсить руками
* Как пишут в проде — спрашивайте практиков.

## Манипуляторы и свои манипуляторы [00:10]
```
std::cout.setf(std::ios::hex); // Теперь все числа выводятся в HEX
std::cout << std::ios::hex; // Аналогично
```

https://accu.org/index.php/journals/1769

```
struct hex_impl {} hex; // Можно объявить глобальную переменную и сделать для её типа operator<< с любым поведением
ostream& hex(ostream& os) { ... } // Есть перегрузка operator<< для функций
struct eat {
    eat(char _c) : c(_c) {}
    istream& operator()(istream &is) {
        ...
    }
private:
    char c;
};
std::cin >> eat('x'); // eat('x') — это объект с `operator()`, очень похоже на функцию
```
