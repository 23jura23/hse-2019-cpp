# Ошибки с прошлой лекции [00:05]
```
int *x = malloc(n * sizeof(int));
```

1. Что делает?
2. Ошибка первая: я говорил, что скобки можно не писать.
   На самом деле, в случае `sizeof(int)` писать обязательно.
   Можно не писать только в таком случае:
   ```
   int a[10];
   int *b = malloc(sizeof a);
   b[5] = a[5];
   ```
   Тут мы говорим "выдели памяти столько, сколько занимает переменная `a`",
   то есть под массив из десяти интов.
   Тогда можно скобки не писать.
   Но с таким тонкость:
   ```
   int *a = malloc(10 * sizeof(int));
   int *b = malloc(sizeof a);
   b[5] = a[5]; // UB, почему?
   ```
3. Ошибка вторая: на самом деле кастовать `void*` в Си не надо, происходит автоматически и это не предупреждение.
   А вот в C++ это ошибка.
   Поэтому в Си просто каст не пишите никогда.

# Пример кучи: многомерные массивы [00:10]
## Выделение многомерных массивов глобально/на стеке
```
int a[3][4];
a[1][2] = 10;
```

## Как представлять многомерные массивы (layout)
По строчкам подряд в памяти: 12 ячеек.
Тогда `a[0][2] ~~~ a[1 * 4 + 2]`.

А можно как массив массивов (`int **a`, указывающий на строчки).

## В других языках
Такого разделения нет, потому что не знаем, как хранятся данные в памяти.
В Python обычно везде массивы массивов.

## Выделение массива массивов в куче
Сначала выделить массив под указатели на строчки, потом каждую строчку.
Нет гарантий, что они идут подряд.
Но строчки могут быть разной длины и длины, известной только в рантайме (этап выполнения).

## Выделение двумерного массива в куче
Надо, чтобы компилятор мог преобразовать `a[i][j]` в `((int*)a)[i * M + j]`, для этого
ему надо знать `M` на этапе компиляции.
То есть надо фиксировать все измерения, кроме первого.

```
int (*a)[4][5] = malloc(sizeof(int) * 3 * 4 * 5);
```

## Массив массивов на глобально/на стэке
Можно, но зачем?

# Препроцессор [00:07]
* Токен — обычно последовательность непробельных символов.
* `#include` — вставить файл.
* `#define` — заменить токен на другой. Или функцию.
  ```
  #define N 100000
  #define N 100000 + 1
  int y = 2 * N;
  #define max(a, b) (a < b ? a : b)
  int x = max(foo(), bar())
  ```
  Странные ошибки компиляции:
  ```
  int N = 10;
  int max(int a, int b);
  ```

Поэтому есть определённые правила написания не ужасных `#define`, но их не надо писать:
* Везде есть функции (но не любой макрос можно выразить как функцию).
* В C++ есть `const int N = 100000 + 1;`.
* Для типов есть `typedef`.

# Указатели: ещё детали [00:08]
* Напоминание.
* Нулевой указатель не указывает никуда.
  Обращаться по нему нельзя.
  Называется `#define NULL ((void*)0)` (в C++ — `nullptr`)
* Новая ошибка:
  ```
  void read_data(int *arr) {
      int n = ...;
      arr = malloc(n * sizeof(int)); // Массив не локальный.
      // ...
  }
  int main() {
      int *data;
      read_data(data);
  }
  ```
  Проблемы: забыли `free`, `arr` в `main` не меняется.
  Решение: указатель на указатель.
  Подсказка: в Си, когда вы видете передачу переменной в функцию, она принципиально не может измениться.

# Структуры [00:30]
## Базовое [00:10]
Структура — это тип данных, который можно создать самостоятельно.
Вроде `record` в Pascal, класса в Java и Python или `namedtuple` в Python.
Ещё аналогия с Python: это как кортеж, но у всех элементов есть имена и типы.

Пример: есть товар с названием и ценой в копейках.
Надо сначала объявить структуру:
```
struct product {
    char name[256];
    int price_kop; // kopek, kopeck
}; // Осторожно с точкой с запятой, она тут нужна (потому что можно сразу объявить переменную такого типа).
```
Внутри фигурных скобок объявлем в любом порядке __поля__ . Имена и типы важны, порядок пока неважен.
Можно массивы, можно указатели.

Дальше появляется тип `struct product` (не просто `product`!).
Было:
```
char name[256];
int price_kop;
strcpy(name, "Laptop");
p.price_kop = 30 * 1000 * 100;
```
Стало (а на стэке примерно то же самое):
```
struct product p; // Объявили переменную, в ней сразу есть `name` и `price_kop`.
strcpy(p.name, "Laptop");
p.price_kop = 30 * 1000 * 100;
```

Доступ к полям — через точку, как и в остальных языках.

## Семантика [00:10]
Value-семантика (Си и C++) и reference-семантика (остальные языки):

* Данные всегда есть (иногда неинициализированы),
  сразу выделяется блок подряд идущей памяти на месте переменной,
  не надо `new`, нет `NULL`.
* Переменные всегда независимы (нарисовать коробочки):
  ```
  // код выше на доске
  struct product q;
  q = p;
  q.price_kop *= 20;
  // p.price_kop == 3000000
  // q.price_kop == 6000000
  ```
  В Python/Java бы они указывали на один и тот же объект (reference-семантика).
* Следствие: оператор `=` работает за линию, потому что надо скопировать все байты.
* Тонкость:
  ```
  struct product {
      char *name;
      int product;
  };
  ```
  Тут копироваться будет только значение указателя.
* Пример
  ```
  void read_product(struct product p) {
      scanf("%255s%d", &p.name, &p.price_kop);
  }
  int main() {
      struct product p;
      read_product(p);
  }
  ```
  В чём проблема? Переменная `p` принципиально не может измениться.
  Надо передавать указатель на `p`.
* А вот тут всё окей:
  ```
  void print_product(struct product p) {
      printf("%s %d\n", p.name, p.price_kop);
  }
  ```
  Как передаётся? Честно на стэке выделяется `sizeof(struct product)` байт, то есть несколько сотен.
  Можно экономить при помощи указателей.

## Хранение в памяти (layout) [00:05]
Поля хранятся подряд, переменная — большая коробочка.
Может быть выравнивание, так что sizeof обычно делится на 4 или на 8.
```
struct Foo {
    char a;
    int b; // Адрес должен делиться на 4.
    char c;
}; // sizeof(struct Foo) == 12
```
Нарисовать коробочку, обратить внимание на `struct Foo` вместо `Foo` в Си.

И от порядка меняется:
```
struct Foo {
    char a;
    char c;
    int b;
}; // sizeof(struct Foo) == 8
```

## Typedef [00:05]
В Си: typedef, чтобы не писать слово struct, обычно делают так:
```
typedef struct product product_t;
// или
typedef struct product {
   ...
} product_t;
```

Осторожно с POSIX и `_t`!
На самом деле там ещё куча имён зарезервированы: https://stackoverflow.com/a/228797/767632
Я рекомендую так, но это лишь на нашем курсе, вообще смотрите конвенции проекта:
```
typedef struct product product;
```

# Универсальная сортировка [00:15]
## Базовое [00:07]
Задача: написать универсальную сортировку пузырьком на Си: любой тип данных, его надо переставлять и сравнивать, и размер неизвестен.
Начнём с сигнатуры:
```
void sort(void *data); // Точно надо указатель, точно на void, мы не знаем тип.
```

Ещё надо количество элементов:
```
void sort(void *data, int n);
```
В чём отличие от других языков: мы не знаем по указателю размер памяти, куда он указывает.
Остальные языки это таскают с собой.

Дальше нужно получать элемент по номеру надо.
Как? Арифметика-то не работает. Нужен размер элемента:
```
void sort(void *data, int n, size_t element_size);
int arr[10];
sort(arr, 10, sizeof(int));
sort(arr, 10, sizeof arr[0]);
sort(arr, sizeof arr / sizeof arr[0], sizeof arr[0]); // Осторожно!
int *parr = ...
sort(arr, sizeof parr / sizeof parr[0], sizeof parr[0]); // Осторожно!
```
В чём отличие от других языков: мы не знаем по указателю тип, куда он указывает.
Остальные языки это таскают с собой.

Как теперь написать свой `swap`? Побайтово:
```
void swap(void *a, void *b, size_t element_size) {
    // Цикл по char*, если успеваем.
}
```
Вообще для этого есть `memcpy`.

## Указатели на функции и вызов `sort` [00:08]
Как сравнивать?
Можно побайтово, это даже работает для `int` и `double`, но не для структур.
Поэтому хотим как-то передать функцию:
```
void sort(void *data, int n, size_t element_size, ??? cmp)
int int_cmp(int *a, int *b) {
    return *a < *b ? -1 : *a > *b;
}
int arr[10];
sort(arr, sizeof arr / sizeof arr[0], sizeof arr[0], int_cmp);
```

У функции тоже есть адрес — первая инструкция. Можно получить указатель на функцию.
Передадим его в `sort`:
```
void sort(..., int (*cmp)(int, int) );
```
Можно ещё взять `typedef`, можно сделать `cdecl.org`.

Функции автоматически преобразуются в указатели на себя и обратно, так что вызов `sort` верный.
А вызов внутри `sort` будет такой:
```
int cmp_res = cmp(x, y);
```

# Библиотеки [00:05]
* Зачем ещё могут быть нужны указатели на функции? Динамические библиотеки или даже плагины.
* Можно взять произвольный файл `*.so` (Linux) или `*.dll` под Windows,
  загрузить в память, попросить указатель на функцию с нужным именем, вызвать.
* Ещё это иногда поддерживается на уровне языка: объявляем функцию, говорим,
  что она будет в такой-то динамической библиотеке, а ОС (загрузчик)
  сам всё загрузит и нам даст нужные указатели.
  Подменили файл, перезапустили программу — ура, новая версия библиотеки.
* Ещё бывают статические библиотеки: `*.a`, `*.lib`, они вкомпилируются
  в исполняемый файл.
  Почти ничем не отличаются от объектных файлов.
