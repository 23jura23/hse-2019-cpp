# Вопросы по домахе [00:10]
* Обращаю внимание на обновление: https://github.com/evlinsky/cpp/commit/eff68e6e3a7c7ede7c1ac0561078f54a65eb10cb#diff-96d065e21be8afa36bac8e2373ba8f26
* Отвечаю на вопросы, если они есть

# Strict aliasing [00:15]
* Строгое определение:
  * https://ru.stackoverflow.com/a/503266/210302
  * https://stackoverflow.com/a/99010/767632
  * https://stackoverflow.com/a/29676395/767632
  * Если у нас есть обьект динамического типа `T`, то мы можем обращаться в нему только через определённые виды указателей:
    * `T`, похожий на него (подобавляли `const`)
    * `char`, `unsigned char` (не `signed char`!), `std::byte`
    * Агрегат, который включает в себя `T` (то есть создали агрегат "вокруг" объекта, но тут я не уврен).
  * Доступ по указателю на `Base*` на самом деле осуществляется к подобъекту, тип совпадает, тут проблем нет.
  * Доступ по указателю на элемент массива тоже осуществляется к подобъекту массива, тип совпадает.
* Мотивация:
  ```
  int some_int;
  void foo(double *some_double) {
      some_int = 1;
      *some_double = 3.1415;
      bar(some_int);  // some_int == 1? Посмотреть на godbolt с разными оптимизациями и `-fno-strict-aliasing`
  }
  ```
* Как можно алиасить, если очень надо:
  * В C++: завели второй объект другого типа и в него скопировали через `char*` или `memcpy`
  * Некоторые компиляторы также позволяют это делать через `union`, но это нестандартное поведение.
* Странные последствия:
  * https://travisdowns.github.io/blog/2019/08/26/vector-inc.html
  * Рекомендация: мерять, надо ли заменять `char` на что-нибудь другое (`int8_t`?).
* Ссылки:
  * https://stackoverflow.com/a/99010/767632
  * https://blog.regehr.org/archives/1307

# Упражнения [00:50]
## Начинаем [00:05]
1. Создать гуглотаблицу с разделением по комнатам.
2. Дать минуту на перемешивание.
3. Разделить.

## Тонкости [00:05]
* `01-basic/06-dynamic-cast.cpp`: осторожно с if statement with initializer.

## В процессе [00:40]
Темы упражнений:

* Базовые
  * Свой `split` для тренировки `string_view`.
  * Инициализация:
    * Свой `initializer_list`: отсортированный вектор.
    * Исправить the most vexing parse: в main и в поле.
    * Добавить в агрегат конструкторы, при этом сохранить старый синтаксис из-за uniform initialization.
  * Касты
    * Заменить C-style каст на реальный каст: `static_cast`, `const_cast`, `reinterpret_cast`.
    * `dynamic_cast`
      * Синтетический пример, чтобы показать if init statement и исключения.
      * Проитерируйтесь по массиву и выведите информацию про все прямоугольники.
* Продвинутые:
  * Инициализация
    * Увидеть, что `{}` может вести себя по-разному для `vector`: `3` не строчка, `0` указатель.
    * Написать свой сложный рекурсивный инициализатор для AST.
  * Замена `dynamic_cast`: visitor для AST.

Разборы:

* 00:10 — `01-basic`: `01-split.cpp`, `02-sort-unique-vector.cpp`
* 00:20 — `01-basic`: `03-the-most-vexing-parse.cpp`, `04-aggregate-to-uniform.cpp`
* 00:30 — `01-basic`: `05-casts.cpp`, `06-dynamic-cast.cpp`
* 00:38 — `03-misc`: `01-vector-quiz.cpp`

# Завершение [00:05]
* Посмотрите в свободное время на решения:
  * `02-yat-builder.cpp` — шаблон "Строитель" для упрощения инициализации. Завели отдельный класс, который умеет строить.
  * `03-yat-visitor.cpp` — шаблон "Посетитель", чтобы можно было один раз сделать иерархию классов
    (например, во внутренностях CLion), а дальше кто угодно (вроде плагинов) может "посещать"
    иерархию, если реализует нужный интерфейс.
* Осторожно с `malloc`/`free` в `05-casts.cpp`, см. [p0593r6](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p0593r6.html)
* Разобрать популярные ошибки из упражнений?
