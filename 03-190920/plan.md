# Вступление [00:15]
## Память в других языках
Везде: есть локальные переменные.
Везде: "под капотом" используется плоская память с байтами.
Вопрос: как в ней что живёт?

* В Python: есть только переменные, мы просто присваиваем значения. Они как-то где-то выделяются: `a = []`.
  Выделили где-то кусок памяти для списка. Добавились элементы - они тоже где-то выделились, как-то связались.
  Никаких гарантий нет, мы принципиально не можем узнать, как элементы лежат в памяти, нет средств языка.
* В Java: есть только переменные и поля, мы для создания нового значения пишем `new`: `ArrayList<Integer> a = new ArrayList<>();`
  Аналогично Python.
* В Pascal: есть только переменные (локальные/глобальные), есть статические массивы: `a: array[1..10] of ...` и динамические: `a: array of ...`,
  у которых потом можно делать `setlength`.
  А со строчками просто работаем.

Интересный вопрос: кто освобождает память?

* Сама ОС удалит всю используемую память, как бы программа не завершилась.
* Но даже в процессе работы освобождение важно для программ, которые работают долго.
  Например, игра: если каждый снаряд хранится в памяти всю игру, память кончится.
  Например, браузер: если закрыли вкладку, память надо освободить.
* Сам язык следит за указателями и освобождает. "Сборка мусора".
* Сборка мусора - это непросто, потому что могут быть циклы:
  ракета ссылается на игрока-хозяина, а игрок-хозяин знает все свои ракеты.
  Если не указываем на игрока, то ракеты тоже надо удалить.
  В Pascal без указателей проще, там нельзя так просто циклы создать.

## Три вида памяти в C и C++
* Традиционно выделяют три вида памяти.
* Самый простой: глобальные и статические (ожидать поднятия рук) переменные.
  * Фиксированный на этапе компиляции размер.
  * Код для выделения/освобождения автоматически генерирует компилятор.
  * Память выделяется и освобождается ОС при старте/завершении программы.
  * Глобальные инициализируется в каком-то порядке (пример потом).
  * Инициализируются нулями или чем-то таким, потому что это просто и дёшево.
    ОС в любом случае надо что-то сделать с нашей памятью, чтобы не
    дать прочитать данные от других программ.
* Самый популярный: стэк.
  * Локальные переменные, временные значения: `int x = 10; int y = x * x + 5;`
  * Размер стэка постоянно меняется в процессе выполнения: запустили функцию - увеличился,
    закончилась функция - уменьшился.
  * Код для выделения/освобождения автоматически генерирует компилятор.
  * Выделяется и освобождается при входе/выходе из функции.
* Самый общий: куча (heap).
  * Хранит всё что угодно: можно попросить себе X байт памяти подряд, а потом в какой-то момент освободить их.
  * Размер меняется в процессе программы.
  * Код для выделения/освобождения пишет программист.
  * Выделяется при вызове функции `malloc`, освобождается при вызове `free`
* В общем случае неважно, где в плоской памяти выделяются объекты.
  Важно лишь то, что байты одного объекта идут подряд.
  Есть какие-то конвенции про то, где конкретно в памяти выделять стэк/кучу/глобальные переменные,
  но это отдельная тема, мы не будем углубляться.

# Стэк [00:15]
## Локальные переменные и возврат значений: где?
* Пусть есть функция, где в памяти расположить переменные?
```
double hypot(double a, double b) {
    return a * a + b * b;
}
```
  Наивный подход: выделим специальные места по фиксированным адресам
  для переменных, временных значений, возвращаемого значения.
  Можно даже воспользоваться конкретными __регистрами__ процессора.
* Аргументы здесь и дальше всегда включаются в локальные переменные,
  просто считаем, что у них есть исходное значение.
* Добавим рекурсии:
```
int fib(int n) {
    if (n <= 1) return 1;
    else return fib(n - 1) + fib(n - 2);
}
```
  Возникают проблемы: у нас может быть очень большая вложенность,
  надо хранить много промежуточных значений.
  Либо компилятору надо догадаться, как переписать без рекурсии.
* Идея: "стэк вызовов".
  * Для каждой функции мы точно знаем, какие у неё локальные переменные, аргументы, возвращаемое значение и сколько места занимают.
  * Назовём это "стековым кадром" (stackframe, кадр стэка).
  * Надо для каждой функции, которая работает, хранить кадр.
* А дальше будем располагать стэковые кадры в памяти подряд.
  * Вызвали функцию - выделили новый кадр, ушли из функции - убрали.
  * Очень удобно, что все кадры идут подряд.
  * Традиционно в x86 стэк растёт от бОльших адресов к меньшим, есть указатель на первый
    байт в каком-то стеке (`esp`, stack pointer)
  * Есть инструкции процессора `push` и `pop`, пример с `pushd 10`.
* Традиционная структура стекового кадра на примере с `fib` и нумерацией строк
  (вообще это называется "соглашение о вызове", calling convention, их много разных).
  Вот cdecl:
  ```
  int fib(int n) {
  1:  if (n <= 1) return 1;
  2:  int a = fib(n - 1);
  3:  int b = fib(n - 2);
  4:  return a + b;
  }
  ```
  * Перед вызовом:
    * Запихнули на стэк аргументы в каком-то порядке (справа налево, т.о. на вершине стэка оказался первый аргумент).
      * Кстати, следствие: неизвестно, в каком порядке аргументы будут вычисляться.
        Например: `foo(readInt(), readInt())`.
    * Потом адрес возврата (номер строки)
    * Потом вызвали функцию, она себе выделила переменные.
  * После вызова:
    * Функция кладёт в регистр процессора результат.
    * Функция удаляет локальные переменные со стэка.
    * Берёт адрес возврата и переходит на него.

## Оптимизации стэка
* Иногда можно передавать аргументы не через стэк, а через регистры.
  Тогда в простых случаях вроде `hypot` можно стэк не выделять.

## Размер стэка
* Под Windows: задаётся в скомпилированном файле, можно указать при компиляции.
  ОС такой стэк и выделяет.
* Под Linux: ОС выделяет фиксированное количество для всех процессов,
  можно иногда поменять для нескольких процессов (`ulimit -s`).

## В других языках
* Стэк есть везде. Везде примерно так и работает.
* Возможно, не так низкоуровнево, но у каждой
  функции всегда есть свой "кадр" с локальными переменными
  и адресом возврата.

## Ошибки
* Нельзя возвращать указатель на локальную переменную.
  Или локальный массив.
  Время жизни не сошлось.
* Переполнение стэка: записали в локальный массив
  по несуществующему адресу.
  Для глобальных переменных как бы окей, а со стэком
  мы потенциально залезли в другую функцию.
  Так можно взламывать программы.
* В C и C++ локальные переменные не инициализируются
  ничем, в них мусор, чтение мусора - UB.
  Почему не инициализируются? Потому что когда-то не хотели
  тратить на это время.

## Скорость работы
* Очень быстро: выделить переменные - это вычесть число из регистра,
  быстрее не бывает.

## Время жизни
* Память существует долго, но логически переменная живёт в своём
  месте только пока живёт функция.
  Попытаемся обратиться потом - undefined behavior.

## Когда (не) использовать
* Практически всегда надо, потому что очень редко нужно хранить
  глобальное состояние.
  А стэк автоматически чистится.
* Не надо использовать для больших объектов, которые активно передаются
  между функциями.
  Там лучше кучу и указатели (будет дальше).
* Хвостовая рекурсия: факториал.
  Вообще не стоит, но некоторые компиляторы могут догадаться,
  что это на самом деле цикл.

# Глобальные переменные [00:15]
## Глобальные переменные
* Пример: генератор случайных чисел из C:
  ```
  int last_rand = 10;
  int rand() {
      last_rand = (last_rand * 123 + 56) % 257;
      return last_rand;
  }
  ```
* Переменная выделяется и инициализируется один раз операционной системой.
* Переменная видна всему файлу. Кто угодно может прочитать/записать.
* Можно инициализировать сложными выражениями, компилятор их посчитает или вызовет
  ещё до `main()`:
  ```
  int x = 2;
  int last_rand = x * 5;
  int rand() { ... }
  ```

## Статические переменные
* Тот же пример, но теперь переменная живёт только внутри функции:
  ```
  int rand() {
      static int last_rand = 10;
      last_rand = (last_rand * 123 + 56) % 257;
      return last_rand;
  }
  ```
* Переменная выделяется ОС один раз, а вот инициализируется - только при первом заходе в функцию.
* Живёт между вызовами функции.
* В языке C++ (не Си) для инициализации можно использовать локальные переменные, но не стоит:
  ```
  int foo(int n, int m) {
      static int nm = n * m;
      // ...
  }
  ```

## Линковка
* Можно посмотреть на глобальную переменную из другого файла:
  ```
  extern int last_rnd;
  int get_last_rand() {
      return last_rnd;
  }
  ```
* Что будет, если забыть `extern`?
* Что будет, если везде написать `extern`?
* Правильно: `extern` в заголовке, а ровно в одном файле определить (там будет выделение и инициализация).
  Как с функциями.

## В других языках
* Аналог в Java - статические поля класса, но они 
* В Python аналогов нет.

## Ошибки
* `static` имеет другой смысл для глобальных переменных:
  ```
  int a = 0;
  static int b = 0;
  void f() {
      static int c = 0;
  }
  ```
* Порядок инициализации внутри файла определён.
  А вот между файлами - нет.
  ```
  // a.cpp
  int ten = 10; // 1.
  int x = ten;  // 2 или 3
  int foo() { return x; }
  // b.cpp
  int y = foo(); // 2 или 3
  ```

## Скорость работы
* Выделяются один раз ОС на этапе загрузки программы в память.
  Очень быстро.
  Освобождается тоже быстро.

## Время жизни
* Живут всё время работы программы.

## Когда (не) использовать
* Глобальные - практически никогда.
  С ними очень сложно следить за программой.
* Статические - иногда можно, но очень, очень аккуратно.
  Плохо работает с рекурсией и надо ручками очищать каждый раз
  при запуске функции.
* На олимпиадах и в контестах можно использовать статические
  вместо глобальных как буфер для чтения:
  ```
  int main() {
      const int MAXN = 100000;
      static char s[MAXN + 1];
      scanf("%s", s);
  }
  ```

# Куча [00:15]
## Основные функции
```
int n;
scanf("%d", &n);
int *a = (int*)malloc(n * sizeof int);
for (int i = 0; i < n; i++) scanf("%d", &a[i]);
for (int i = 0; i < n; i++) printf("%d", a[i]);
free(a);
```
* `malloc(X)` пытается выделить `X` байт подряд и возвращает `void*`,
   указывающий на начало памяти.
  Его потом надо явно привести (cast) к типу `int*` (кастануть).
* `sizeof` на этапе компиляции заменяется на константу - размер типа.
* `free` получает указатель на начало блока, который выделил `malloc`,
  и освобождает.
* Можно просить сколько угодно памяти, если не получится - `malloc` вернёт
  `NULL` (0, `nullptr`).
  По-хорошему надо проверять, иначе UB.
* Единственный способ выделить память неизвестного на этапе компиляции размера.
* Память не инициализируется.

## calloc, realloc
* Есть `calloc` - как `malloc`, но заполняет нулями.
* Есть `realloc` - как `malloc`, но пытается "расширить" выделенную память или скопировать в другое место.
  Используется только в Си (например, для увеличения массивов), в C++ не используется
  (потому что в общем случае не любые данные можно просто переносить из одного места памяти в другое).

## В других языках
* Python, Java: всё лежит в куче.
  Просто нет ничего, кроме кучи, и всё есть указатель, поэтому незаметно.

## Ошибки
* Помним про `sizeof`:
  ```
  void solve(int n) {
      int *a = malloc(n);
      ...
  }
  ```
  Иначе UB и доступ не к своей памяти.
* Помним про `free`:
  ```
  void solve(int n) {
      int *a = malloc(n * sizeof n);
      ...
  }
  ```
  Иначе утечка памяти. Не UB, но неприятно.
  В домашках запрещено.
  Для этой и предыдущих есть address sanitizer, memory sanitizer, valgrind.
  Они ловят.
* Не надо использовать кучу для всего подряд (это не Java):
  ```
  int *p = malloc(sizeof int);
  *p = 4;
  free(p);
  ```
  Занимает в три раза больше места и надо не забыть про `free`

## Скорость работы
* `malloc` и `free` работают очень медленно: им надо как-то найти
  свободный кусок памяти и зарезервировать.
  А ещё делать это так, чтобы не было фрагментации.

## Время жизни
* Выделяется `malloc`, освобождается `free`.
* Вся инициализация - исключительно на совести программиста.

## Когда (не) использовать
* Почти никогда не использовать, если есть возможность.
* Если надо выделить память размера N, где N читается со входа,
  то придётся кучу.
  Но по минимуму: выделяйте ровно в одном месте, освобождайте
  ровно в одном.

# Пример кучи: C-строчки [00:10]
* Копирование строчки:
  ```
  char *copy_string(char *s) {
      int n = strlen(s);
      char *t = malloc(n * sizeof char); // sizeof char == 1 по определению.
      for (int i = 0; i < n; i++) // <= ! null-terminator
          t[i] = s[i];
      return t;
  }
  ```
* В чём ошибки кода ниже?
  ```
  void foo(char *s) {
      char *t = copy_string(s);
      t[0] = 'a'; // Строчка может быть пустой, тогда тут мы потеряли нулевой символ и дальше будет UB.
      printf("%s\n", t);
      // Нет free
  }
  ```

## В других языках
Вся это возня с кучей, выделения и выделения обычно изолированы.
В Python вы об этом не думаете, в Java тоже.
В C++ тоже можно не думать, но потом :)
