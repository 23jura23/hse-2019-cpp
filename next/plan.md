Напоминание: upcast указаталей и ссылок.
Новое: явный downcast указателей и ссылок.

lect11
виртуальность
не тот delete вызывает не тот деструктор.
виртуальный деструктор, автоматически будет override в наследнике.

абстрактный protected-метод, который наследник перезаписывает, а мы вызываем.
vptr
но из конструктора/деструктора вызывать виртуальные методы ой не стоит!

## Нарезка (slicing) [00:05]
* Из-за ссылок в конструктор копирования (даже по умолчанию) можно передать наследника:
  ```
  Queue(const Queue &other) { ... }
  ```
* Тогда во фразе `SizedQueue a; Queue b = a` в `b` окажется копия `a`, которая забыла
  свою длину.
* Вроде ничего страшного, но нарезка (slicing) происходит молча:
  ```
  void foo(slow_queue q);
  fast_queue q;
  foo(q); // Ой, нарезка.
  ```

## Вывод [00:05]
Наследование — это инструмент, иногда полезный (особенно со следующей лекции),
но просто его использовать для экономии места не стоит, можно огрести с нарезкой.

# Ещё дальше
* Placement new (когда-то ещё будет?) и "время жизни объектов != выделена память".
* swap: https://stackoverflow.com/a/5695855
