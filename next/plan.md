list-initialization (uniform initialization syntax).

# Долги
Приватное наследование нужно для, например, boost::noncopyable.
Или какого-нибудь другого свойства, которое требуется всем экземплярам класса.

# Статические члены классов-константы [00:15]
## Линковка обычных констант [00:05]
* Обычно слово `const` для глобальных переменныех автоматически влечёт
  за собой internal linkage: видно только из текущей единицы трансляции.
* Поэтому можно объявлять константы в заголовке и всё работает без ошибок
  multiple definition.
  ```
  // a.h
  const int x = 10;
  // a.cpp
  #include "a.h"
  // b.cpp
  #include "a.h"  // Забыли перекомпилировать после изменения a.h, упс.
  ```
* Заумность: если не хотим — можно дописать `extern`, будет `extern const int x/* = 10*/;`.
  Но так не надо.

## Старый способ для статических [00:07]
* Напоминание: статические члены классов-переменные: обычно должно объявляться в классе
  и определяться снаружи (причём ровно один раз):
  ```
  // h
  struct A {
      static int x;
  };
  // cpp
  int A::x = 10;
  ```
* Константы аналогично:
  ```
  // h
  struct A {
      /*static*/ const int y;
      static const char * /*const*/ s1;
  };
  // cpp
  const int A::y = 10;
  const char* const A::s1 = "foo";
  ```
* Но это не всегда удобно.
  * Надо писать константу не там, где объявлена, даже если это просто число.
  * Компилятору сложнее оптимизировать константы в других единицах трансляции.
  * Нельзя использовать этот `const` для размеров массивов (GCC сможет, потому что
    он умеет в variable length array, VLA):
    ```
    int arr[A::y];
    ```
* Если у нас статическая константа целочисленного типа или enum,
  то можно проинициализировать константной прямо в объявлении.
  ```
  // h
  struct A {
      static const int y = 10;
  };
  ```
  Тогда можно использовать в константных выражаниях.
  * Но если ODR-used, то всё равно нужно ровно одно определение.
  * Пример, когда не нужно: заиспользовали как размер массива: `int arr[A::y];`
  * Пример, когда нужно: взяли адрес: `foo(&A::y);`
  * Пример, когда нужно: инициализируется сложной функцией: `static const int y = foo();`
* Заумность: с C++17 можно сделать inline-переменную (отключит ODR),
  получим `static inline const`, но лучше не надо.

## Хороший способ [00:03]
* Любую константу пробуете сделать `constexpr` вместо `const`.
  Это не часть типа (но автоматически влечёт `const`),
  это дополнительное ограничения компилятору: вычисли на этапе компиляции.
* В противном случае честно объявляете в `.h` и определяете в `.cpp`.

## ADL
Вызов конструктора не находится через ADL (и слава богу, теперь namespace no_adl работает).
friend namespace injection в стандартном C++ нет
https://en.cppreference.com/w/cpp/language/adl
Для `operator<<`
Для `swap`: https://stackoverflow.com/a/5695855
`namespace internal` для отключения случайного ADL
# Ещё дальше
* C++ позволяет специализировать и инстанциировать шаблоны от приватных типов, а оттуда `friend`'ом вытащить, тогда не будет ошибки "тип приватный" (только практики?): https://godbolt.org/z/hH9H27
* Stateful metaprogramming (только практики?): https://stackoverflow.com/questions/44267673/is-stateful-metaprogramming-ill-formed-yet
