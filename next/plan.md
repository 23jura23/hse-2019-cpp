# Неявные преобразования copy initialization
* Выглядит, как неявное преобразование:
  ```
  void print(Array a) { ... }
  int main() {
      Array a(10);
      Array b = 10;
      print(a);
      print(10);
  }
  Array f() { return 10; }
  ```
  Более того: добавим перегрузку `print(int)`, всё изменится.
* Это иногда странно. В C++11 можно отключить конструктор для копирующей инициализации `explicit Array(int n)`.
  Тогда в copy initialization и неявной конвертации использовать нельзя.

# Практические проблемы [00:15]
## Сложные классы [00:08]
* Обычно не надо вообще ничего писать: используем внутри только вектора, всё автоматически создаётся, копируется, удаляется.
  Ну, можно конструктор создать.
* Правило трёх: из destructor, copy constructor, assignment operator вы реализуете либо ноль, либо все три.
  Почему: если потребовалось, то у вас наверняка есть какой-то ресурс.
  В C++11 расширяется до правила пяти.
* Swap trick: реализовали copy constructor, реализовали swap, а в assignment operator делаем swap и берём по значению.
  ```
  Array& operator=(Array other) {
      this->swap(other);
  }
  ```

## Оптимизации [00:07]
* RVO: `Array createArray() { return Array(10); }` (обязательно с C++17)
  Зачем: `Array x = createArray();`, копировать не надо.
* NRVO: `Array createArray(      ) { Array a(10);              return a; }` (необязательный NRVO)
  Зачем: `Array x = createArray();`, копировать не надо.
  В чём проблема: `createArray(bool x) { Array a(10); Array b(20); return x ? a : b; }
* Copy elision: можно выкинуть копию, даже если есть побочные эффекты от копирования.
  Не только рядом с `return`: `print(Array(10));`.
  Это одно из двух мест (судя по cppreference), когда оптимизатор _по стандарту_ может менять поведение
  программы, а не просто из-за UB.

# Ещё дальше
* Вся lect08: const (уже частично было даже с cv-qualifier, надо связать), mutable, static, inline
* Перегрузка функций: подробности (вычисляются на этапе компиляции, как выбирается подходящая)
  * У методов есть const-qualifier
* Параметры по умолчанию: подробности (вычисляются в момент вызова)
* Перегрузка и параметры по умолчанию (а вдруг совпали?)

* Placement new (когда-то ещё будет?) и "время жизни объектов != выделена память".
