# Библиотеки [00:05]
* Зачем ещё могут быть нужны указатели на функции? Динамические библиотеки или даже плагины.
* Можно взять произвольный файл `*.so` (Linux) или `*.dll` под Windows,
  загрузить в память, попросить указатель на функцию с нужным именем, вызвать.
* Ещё это иногда поддерживается на уровне языка: объявляем функцию, говорим,
  что она будет в такой-то динамической библиотеке, а ОС (загрузчик)
  сам всё загрузит и нам даст нужные указатели.
  Подменили файл, перезапустили программу — ура, новая версия библиотеки.
* Ещё бывают статические библиотеки: `*.a`, `*.lib`, они вкомпилируются
  в исполняемый файл.
  Почти ничем не отличаются от объектных файлов.

## Чтение и запись текстовых файлов [00:05]
* Обычно `fscanf` и `fprintf`.
* `fscanf` возвращет количество прочитанных элементов.
  По-хорошему надо всегда проверять.
  ```
  int h, m;
  assert(fscanf(f, "%d:%d", &h, &m) == 2);  // 11:30
  assert(fprintf(f, "%02d:%02d", h, m) == 5); // Количество записанных символов.
  ```
* Тонкость: `while (!feof(stdin))` не работает.

## Чтение и запись бинарных файлов [00:05]
* Обычно `fread` и `fwrite`:
  ```
  int array[100];
  assert(fread(array, sizeof(int), 100, fin) == 100);
  assert(fwrite(array, sizeof(int), 100, fout) == 100);
  ```
  Зачем разделять размер одного элемента массива и количество элементов?
  Код чуть-чуть удобнее.
  Но вообще каждая функция может записать/прочитать лишь часть элемента, ЕМНИП.
* Ещё бывает `fseek` и `ftell`, которые позволяют перемещаться внутри файла и
  читать из произвольного места.
  Получаем этакий массив, в котором можно быстро читать подряд идущие кусочки
  и медленно менять позицию.
* Эти ребята плохо работают между системами: выравнивание структур, разный размер
  под разными системами, порядок байт внутри `int`...
