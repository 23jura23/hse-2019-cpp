# Разбор теста [00:20]
* Как прошло? Какой формат лучше?

## [00:03]
* (1), исключения:
  * Деструкторы вызываются всегда
  * Исключения не знают границ функций
  * `throw;` выбрасывает "текущее исключение"
  * В `catch` ловится как будто при присваивании переменной. В частности, slicing при ловле по значению.

## [00:05]
* (2), (3), гарантии
  * Сначала смотрим на исключения
    * В `make_unique` выделение памяти
    * В любых(!) операциях с `T` любые исключения без гарантий(!)
  * Базовая гарантия
    * В нашем классе `unique_ptr` => напрямую память не утекает.
    * В конструкторе она есть, если конструктор копирования, перемещания и деструктор (список неточный) `T` дают базовую.
    * В `removeAll` надо базовую ещё и от `==`
    * В `setTo` надо базовую ещё и от оператора присваивания.
  * Строгая гарантия
    * Всегда сначала создаём новые данные, а дальше подменяем старые на новые.
    * В конструкторе есть, если попросить строгую от `T`
    * В `removeAll` надо либо попросить nothrow от `==` и деструктора, либо сначала проверить, а потом делать `reset()`.
      И, конечно, строгую гарантию от `==`.
    * В `setTo` надо строгую гарантию от конструктора копирования `T`. И сначала создавать новые указатели,
      а потом портить старые.
  * Nothrow
    * В конструкторе и `setTo` никак, потому что выделение памяти.
    * В `removeAll` надо nothrow от `==`

## [00:07]
* (4), касты
  * Нарисовать картинку.
  * `Derived` и `Derived2` — обычное наследование: либо неявное, либо `static_cast`.
    * Можно ещё `dynamic_cast` (так как классы полиморфные <=> есть виртуальный метод <= есть виртуальный деструктор),
      но он может давать ложное ощущение безопасности и тормозит.
      Тут скорее подразумевался `static_cast`, потому что мы на этапе компиляции знаем объект.
  * В случае с `Base` снова хватает неявного каста, потому что нет неоднозначностей из-за виртуального наследования.
    * Константность навесить можно неявно.
  * А вот из `Base` в `Foo` так просто через `static_cast` нельзя, потому что виртуальное наследование.
    * Обязаны делать `dynamic_cast<const Foo*>`. К счастью, C-style тут не скомпилируется.
    * При этом через `void*` или `reinterpret` — ошибка.
  * Аналогично с cross-cast от `Foo` в `Bar`: только `dynamic_cast`.
    * Тут C-style уже скомпилируется как `reinterpret`, будет UB.
  * Из `Foo` в `Derived` уже можно `static_cast`.
  * Из `ddd` в `cddd` надо `static_cast`+`const_cast`.

## [00:03]
* (5), инициализация
  * Тонкость: `explicit` никогда не участвует в перегрузке со знаком `=`
  * Тонкость: `{}` запрещают округление
  * Тонкость: надо уметь выводить шаблонные параметры конструктора, иначе SFINAE.
  * Не должно было быть проблем с приоритетом конструкторов: всё однозначно.

## [00:02]
* (6), STL
  * Я хотел упражнение на `lower_bound`, но он здесь бесполезен: удаление из списка идёт за O(ответа), но поиск линейный.
  * Поэтому достаточно сделать `remove_if`. Если не помните — написать руками (`it = l.erase(it)`).
  * Если время есть: но давайте напишем компаратор.

# Долги [00:20]
TODO

## Перегрузка `operator->` [00:05]
* Перегрузка `operator->` по цепочке
  * Пример: возвращаем умный указатель
* Время жизни возвращённого по значению временного объекта (как обычно, до конца full expression)

## Rvalue-ref-qualified functors [00:05]
* Функтор тоже надо perfect forward! rvalue-ref-qualified, например.

## Мелочи [00:10]
* Precompiled header для ускорения компиляции
* `friend class`
* `thread_local` переменные (работают как `static`)
* Определение метода класса вне класса, который возвращает вложенный класс (`HuffmanTree::Node HuffmanTree::foo()`) — удобно через auto
* Нельзя шаблонизировать конструкторы/операторы копирования/присваивания: компилятор сгенерирует версию по умолчанию,
  которая будет приоритетнее `template<typename T> MyClass(const T&)`.
  * Swap trick работает, потому что стандарт разрешает `operator=(MyClass)`.
  * Видимо, надо ооочень аккуратно смотреть на user-defined/user-declared/implicitly defined-deleted, whatever. TODO
* declval + comma operator in return value

# Parameter pack (variadic template) [00:40]
TODO

Задача: много параметров в perfect forwarding

* Синтаксис, группировка, sizeof…

Работа с индексами и более сложная распаковка-запаковка, несколько parameter pack.
Задача: strcat, который выводит в stringstream. Может с разделителем.

* Захват parameter pack в лямбду
* Index_sequence, make_index_sequence
* Шаблонные лямбды (`auto` и `[]<template>()`), чтобы не делать invokeImpl, а делать IIFE
* fold expressions с C++17: делаем strcat наивно с operator<<
* Рекурсия в функциях для сложных вычислений
* `initializer_list` в конструкторах

Реализация tuple через рекурсивное наследование.

* Синтаксис `<auto ...Params>` и `<auto Param>` с C++17.

## Что можно получить
* `forward_as_tuple` (и понять, почему типы именно такие), `std::apply`, `std::invoke`
* Теперь можно сделать объект `log`, который имеет `operator()` и логирует все вызовы и аргументы
  (если они форматируемые), при этом делает perfect forward и сам следит за вложенностью отступов.
* Можно сделать мок: запоминает все вызовы, потом в тесте проверили.
* Распад аргументов (надо при сохранении в поля?)
  * `std::array` (не decay’ится)
  * `decay_t` вместо `remove_cvref`
