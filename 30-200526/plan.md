# Разбор теста [00:20]
* Как прошло? Какой формат лучше?

## [00:03]
* (1), исключения:
  * Деструкторы вызываются всегда
  * Исключения не знают границ функций
  * `throw;` выбрасывает "текущее исключение"
  * В `catch` ловится как будто при присваивании переменной. В частности, slicing при ловле по значению.

## [00:05]
* (2), (3), гарантии
  * Сначала смотрим на исключения
    * В `make_unique` выделение памяти
    * В любых(!) операциях с `T` любые исключения без гарантий(!)
  * Базовая гарантия
    * В нашем классе `unique_ptr` => напрямую память не утекает.
    * В конструкторе она есть, если конструктор копирования, перемещания и деструктор (список неточный) `T` дают базовую.
    * В `removeAll` надо базовую ещё и от `==`
    * В `setTo` надо базовую ещё и от оператора присваивания.
  * Строгая гарантия
    * Всегда сначала создаём новые данные, а дальше подменяем старые на новые.
    * В конструкторе есть, если попросить строгую от `T`
    * В `removeAll` надо либо попросить nothrow от `==` и деструктора, либо сначала проверить, а потом делать `reset()`.
      И, конечно, строгую гарантию от `==`.
    * В `setTo` надо строгую гарантию от конструктора копирования `T`. И сначала создавать новые указатели,
      а потом портить старые.
  * Nothrow
    * В конструкторе и `setTo` никак, потому что выделение памяти.
    * В `removeAll` надо nothrow от `==`

## [00:07]
* (4), касты
  * Нарисовать картинку.
  * `Derived` и `Derived2` — обычное наследование: либо неявное, либо `static_cast`.
    * Можно ещё `dynamic_cast` (так как классы полиморфные <=> есть виртуальный метод <= есть виртуальный деструктор),
      но он может давать ложное ощущение безопасности и тормозит.
      Тут скорее подразумевался `static_cast`, потому что мы на этапе компиляции знаем объект.
  * В случае с `Base` снова хватает неявного каста, потому что нет неоднозначностей из-за виртуального наследования.
    * Константность навесить можно неявно.
  * А вот из `Base` в `Foo` так просто через `static_cast` нельзя, потому что виртуальное наследование.
    * Обязаны делать `dynamic_cast<const Foo*>`. К счастью, C-style тут не скомпилируется.
    * При этом через `void*` или `reinterpret` — ошибка.
    * Можно было понять, тут надо чисто сишный каст перевести и написать `reinterpret_cast`. Надо опросить, кто так думал и поставить балл.
  * Аналогично с cross-cast от `Foo` в `Bar`: только `dynamic_cast`.
    * Тут C-style уже скомпилируется как `reinterpret`, будет UB.
  * Из `Foo` в `Derived` уже можно `static_cast`.
  * Из `ddd` в `cddd` надо `static_cast`+`const_cast`.

## [00:03]
* (5), инициализация
  * Тонкость: `explicit` никогда не участвует в перегрузке со знаком `=`
  * Тонкость: `{}` запрещают округление
  * Тонкость: надо уметь выводить шаблонные параметры конструктора, иначе SFINAE.
  * Не должно было быть проблем с приоритетом конструкторов: всё однозначно.

## [00:02]
* (6), STL
  * Я хотел упражнение на `lower_bound`, но он здесь бесполезен: удаление из списка идёт за O(ответа), но поиск линейный.
  * Поэтому достаточно сделать `remove_if`. Если не помните — написать руками (`it = l.erase(it)`).
  * Если время есть: но давайте напишем компаратор.

# Долги [00:10]
Всё только на слайдах.

* Перегрузка `operator->` работает по цепочке (`02-debt/01-arrow.cpp`).
  * Время жизни возвращаемого объекта — до конца full expression (`02-debt/01-arrow-lifetime.cpp`, там стоит пройтись отладчиком).
* Функтор тоже надо perfect forward, не только аргументы:
  ```c++
  struct Foo {
      void operator(int) && {};
  };
  template<typename Fn, typename Arg>
  decltype(auto) wrap(Fn &&fn, Arg &&arg) {
      return std::forward<Fn>(fn)(std::forward<Arg>(arg));
  }
  ```
* Precompiled header для ускорения компиляции
* `friend class`
* `thread_local` переменные (работают как `static`)
* Определение метода класса вне класса, который возвращает вложенный класс (`HuffmanTree::Node HuffmanTree::foo()`) — удобно через auto
* Нельзя шаблонизировать конструкторы/операторы копирования/присваивания: компилятор сгенерирует версию по умолчанию,
  которая будет приоритетнее `template<typename T> MyClass(const T&)`.
  * Swap trick работает, потому что стандарт считает `operator=(MyClass)` copy assignment.
  * А вот копирующий конструктор обязан быть нешаблонным и принимать первый аргумент в точности `T&` (возможно, cv-qualified).
* Pimpl: что такое, когда надо, как гуглить, идея.

# Parameter pack (variadic template) [00:25]
Всё в основном на слайдах.

https://en.cppreference.com/w/cpp/language/parameter_pack

## Variadic template [00:10]
* Теория и определения для структур/классов
  * Template parameter pack
  * Variadic template
* В основном шаблоне можно ставить parameter pack только в конце.
  * Чтобы можно было читать параметры от первого к последнему жадно.
* Оператор `sizeof...()` возвращает `std::size_t`
* Pack expansion для `typename ...Ts`
  * `tuple<Ts...>`
  * `template<Ts ...Values> struct other {}`
    * Синтаксис `<auto ...Params>` и `<auto Param>` с C++17.
  * В списке наследников, в member initialization list
    * Объявлять так члены или переменные нельзя, приходится `std::tuple<>`.
  * В `using` (начиная с C++17), например, для variant type detector через перегрузки.
* Получить элемент по номеру никак нельзя, только pattern matching через частичную специализацию.
* В частичных специализациях
  * https://en.cppreference.com/w/cpp/language/partial_specialization
  * Parameter pack может быть где угодно, но:
    * В `Foo<A, B, C...>` разворачивать можем только последний.
  * Если разворачиваем parameter pack напрямую, то должен быть последним.
    * Чтобы можно было читать параметры от первого к последнему жадно.
  * Если разворачиваем parameter pack где-то внутри, то тоже окей:
    ```c++
    template<typename, typename, typename> struct Foo {};
    template<typename ...As, typename T> struct Foo<T, tuple<As...>, T> {};
    ```

### Реализация `tuple` [00:07]
* Делаем рекурсивный `tuple` через pattern matching.
  * Специализируем пустой `tuple<>`.
  * Специализируем через `Head` и `Tail`.
* `tuple_size` делается через `sizeof...`
* `tuple_element` делается рекурсивно.
* Для `get<>` надо специализировать функцию `get<>`.

### Одновременное разворачивание [00:03]
```c++
template<typename ...As, typename ...Bs> struct ZipTuple<tuple<As...>, tuple<Bs...>> {
    using type = tuple<pair<As, Bs>...>;
}
```
* Если внутри одного pattern есть несколько parameter pack, они должны быть
  одинакового размера, тогда разворачиваются "параллельно".

### Возврат parameter pack невозможен [00:05]
* Попробуем написать `reverse` для `As...` как-нибудь рекурсивно.
* Проблема: вернуть variadic template "наружу" нельзя. Нельзя сделать псевдоним для parameter pack, как для типов.
  * `using types = Ts...` не компилируется.
* Единственный способ — завести себе `template<typename...> struct type_list {};` и дальше работать в его терминах.
  * `using type = type_list<Ts...>` компилируется
  * Но дальше надо будет аккуратно делать вспомогательный шаблон для применения `type_list` к другому шаблону вроде `tuple`
    * В общем случае посмотрите на https://stackoverflow.com/a/38009838/767632
* Декартово произведение надо эмулировать руками или библиотекой: писать конкатенацию, потом как-то применять `type_list` куда надо.
  * Пример: пусть мы сделали `Cartesian<type_list<As...>, type_list<Bs...>>`, теперь делаем
    `Helper<tuple<As>, tuple<Bs>> = HelperImpl<Cartesian_t<tuple_list<As...>, tuple_list<Bs...>>>`,
    где `HelperImpl<type_list<Xs...>> = tuple<Xs...>`

# Function parameter pack [00:35]
Всё в основном на слайдах.

https://en.cppreference.com/w/cpp/language/parameter_pack

## Синтаксис и perfect forwarding [00:10]
* Если шаблонная функция и есть template parameter pack,
  то его можно развернуть в function parameter pack: `void foo(Args &&...args)`.
  * Тут сразу работают pattern.
  * Пока нельзя сказать "сколько-то аргументов одного типа".
  * Это не variadic function, variadic function — это из Си.
* Тут parameter pack можно где угодно, если функция в состоянии его вывести из аргументов
  * Предназначено для работы как у частичных специализаций: последний параметр точно ок, спрятанный в аргумент точно ок.
  * `(Args1..., nullptr_t, Args2...)`, например, не справится.
* Получить элемент по номеру никак нельзя, только pattern matching через перегрузку функций.
  Или через вспомогательную структуру.
* Pack expansion для `(Args ...args)` или для `<int ...Args>`:
  * В качестве параметров в другие функции, инициализацию, `new`, любые круглые скобки.
    * `make_unique`, `emplace`, сначала без perfect forwarding.
    * Можно даже с perfect forwarding: `std::forward<Args>(args)...`.
    * `std::invoke` для функций, намекнуть на указатели на члены
  * В фигурные скобки (причём порядок вычислений становится определён):
    ```c++
    int res[] = {args...};
    int dummy[] = { (std::cout << args, 0)... };
    ```
  * В lambda capture (по значению, ссылке, но не как move, там надо с `tuple`)
* Идея: можно что угодно сделать рекурсивно (найти i-й элемент, найти минимум, найти int).
  * Можно вспомогательную структуру `FooHelper` со специализациями.
  * Можно вспомогательную функцию с перегрузками.

## Fold Expressions [00:10]
В C++17 появилось.
https://en.cppreference.com/w/cpp/language/fold

* `return (... + args);` скобочки вокруг обязательны.
  * Обязателен хотя бы один `args`.
  * `(arg0 + arg1) + arg2`
  * `(args + ...)` наоборот: `arg0 + (arg1 + arg2)`
* Ещё можно `(0 + ... + args)`
  * Работает с пустым `args`
  * `((0 + arg0) + arg1) + arg2)`
  * `cout << ... << args` работает как `((cout << arg0) << arg1) << arg2`, как и ожидается.
    * `cout << args << ...` не сработает (синтаксис не тот)
    * `cout << args...` не сработает (не аргумент функции)
* Можно `bool x = (pred(args) || ...);`, скобочки вокруг обязательны.
* При помощи `,` можно вызывать функцию: `(f(args), ...);`, скобочки вокруг обязательны.
* Можно создать свой класс, перегрузить для него `+` и так делать цикл
  * И ещё много чего странного: https://foonathan.net/2020/05/fold-tricks/
  * Например, так можно вывести аргументы в `cout` через пробел.

## Работа с индексами (не на экзамен!) [00:15]
Задача: `std::apply(Fn, std::tuple<>)`
Если успеем.

* Нам надо `get<0>(t), get<1>(t)` => надо parameter pack `0, 1, 2, ...`.
  * Исходно его нет => должен появиться => его нам как-то передадут.
  * Удобнее всего считать, что он уже лежит в специальном контейнере `std::index_sequence` (`std::integer_sequence`).
    ```c++
    template<typename ...Args, std::size_t ...Indices>
    struct ApplyHelper<std::index_sequence<Indices...>, Args...> {
        template<typename Fn, typename Tuple>
        static decltype(auto) apply(Fn &&fn, Tuple &&tuple) {
            return std::forward<Fn>(fn)(std::get<Indices>(std::forward<Tuple>(tuple))...);
        }
    };
    ```
  * Можно упростить и сказать, что мы пишем функцию и получаем объект типа `integer_sequence` в качестве аргумента:
    ```c++
    template<typename Fn, typename Tuple, typename ...Args, std::size_t ...Indices>
    decltype(auto) apply(Fn &&fn, Tuple &&tuple, type_list<Args...>, index_sequenc<Indices...>) {
        return std::forward<Fn>(fn)(std::get<Indices>(std::forward<Tuple>(tuple))...);
    }
    ```
  * Дальше можно либо руками создавать рекурсивно (написать код), либо `std::make_index_sequence` (что быстрее).
  * Начиная с C++20 можно делать не вспомогательную структуру/функцию, а лямбду `[]<std::size_t ...Indices>(....){ .... }()`.
* `forward_as_tuple` и его отличие от `make_tuple`
  * Не копирует.
  * Понять, почему типы именно такие.
* Теперь можно захватывать parameter pack в лямбду с мувом:
  ```c++
  [t = std::forward_as_tuple(std::forward<Args>(args)...)]() {  // Осторожно: надо perfect forward args
      std::apply(Foo(), std::move(t));  // Осторожно: тут надо move, иначе нельзя делать move из элемента T&& у t.
  }();
  ```
