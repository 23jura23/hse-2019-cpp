# Определение методов вне класса [00:05]
```
struct Array {
    int get(size_t id) const {
        return data[id];
    }
};
```

```
// .h
struct Array {
    int get(size_t id) const;
};
// .cpp
int Array::get(size_t id) const {
}
```

# Типы линковки и хранения объектов (storage duration) [00:40]
* Статья "Storage class specifiers" https://en.cppreference.com/w/cpp/language/storage_duration
* Слова `static`, `extern`, `inline` контроллируют эти два независимых свойства.
* Ещё независимо от этого есть область видимости имени.
* Рисую таблицу 3x3 на всю доску.

## Типы хранения объектов (storage duration) [00:05]
* Automatic: на стэке.
  Оживает в начале `{`, умирает в конце `}`.
  Это все локальные переменные, кроме объявленных со словом `static`.
* Static: существует ровно одна копия на всю программу,
  начинается до `main`, заканчивается после завершения программы.
  Это локальные переменные со словом `static` и глобальные переменные.
  Порядок инициализации (де)инициализации не определён (и даже
  вроде может идти параллельно, что совсем грустно).
* Dynamic: ручками выделяем-освобождаем при помощи `new`/`delete`
  в каких-то кусках памяти (в куче).

## Типы линковки (linkage) [00:05]
* No linkage: можем обращаться к сущности только из того же блока.
  * Локальные переменные, typedef, классы...
  * Тут может быть не больше одного определения, компилятор наверняка контроллирует.
* External linkage. 
  Можем обращаться из любых translation unit.
  * Глобальные переменные, классы, методы.
  * Любые функции (в том числе объявленные внутри фигурных скобок).
  * Должно быть ровно одно определение (ODR), можно нарушить, будет UB, можно без ошибок.
* Internal linkage.
  * Можем обращаться из любой точки своего translation unit, но не из других.
  * Тут может быть не больше одного определения, компилятор наверняка контроллирует.

## Влияние ключевых слов: `extern`, `static` [00:20]
* Любая функция
  * Не объект, external linkage.
  * Должно быть ровно одно определение.
* Локальная переменная
  * Automatic, no linkage.
* Глобальная переменная
  * Static, external linkage.
* Глобальная переменная `extern` (и локальная тоже!)
  * Static, external linkage, только объявление, не определение.
  ```
  // a.cpp
  extern int B; // static, external linkage
  int foo() { /* extern int B; */ return B; }
  // b.cpp
  int B;  // static, external linkage
  void bar() { B = 10; }
  ```
* Локальная переменная со словом `static`
  * Static, internal linkage.
* Глобальная переменная `static`
  * Внезапно: тоже static, и internal linkage.
  * В отличие от обычных глобальных нельзя заиспользовать в других единицах трансляции.
  * В C используется, в С++ обычно не используется, потому что `namespace { ... }`.
* Глобальная переменная `static extern`: не бывает.
* Любая функция со словом `static`
  * В C используется, в С++ обычно не используется, потому что `namespace { ... }`.

## `inline`-функции и методы [00:10]
* Функция со словом `inline` и метод, определённый внутри класса
  * Не объект, external linkage.
  * Вы можете подумать, что это пояснение компилятору "встраивай, пожалуйста", но нет.
    Компилятор сейчас сам решает, что ему делать.
  * Исторически - да, и функция должна была писаться в `.h`.
    Это на самом деле разрешение нарушать ODR. Всё остальное — лирика.
    Но реализация должна быть одинаковая во всех translation unit, иначе UB.
  * Зачем сюда всегда включили методы, определённые внутри класса? Чтобы можно было писать класс в `.h`.
* Метод, определённый вне класса - как функция, external linkage.
* Метод, определённый внутри класса - как inline-функция.

# Слово `static` у полей и методов [00:05]
* У полей и методов (появились в C++) слово `static` обрело новый смысл.
* `static`-поле: как глобальная переменная, static, external linkage, надо определить ровно один раз.
  ```
  struct A {
      static vector<int> foo;
  };
  vector<int> A::foo;
  ```
  Отличие от глобальной переменной: видна только внутри класса, больше отличий нет.
* `static`-метод: как глобальная функция, static, external linkage, надо определить ровно один раз.
  Если только не inline.
* Не путать этот `static` с сишным, который internal linkage!

# Приватные конструкторы [00:10]
* Конструкторы без имён и не всегда может быть ясно, что хочется:
  ```
  Settings(); // Настройки из файла по умолчанию
  Settings(); // Пустые настройки?
  Settings(const char *name); // Настройки из файла?
  Settings(const char *name); // Настройки из строчки?
  ```
* Можно сделать какие угодно конструкторы приватными, а дальше
  сделать статические методы, которые генерируют объекты:
* Ещё есть паттерн "синглтон": иногда зачем-то очень хочется
  гарантировать, чтобы был ровно один объект на всю программу:
  ```
  class Settings {
  private:
      Settings();
  public:
      static Settings& getInstance() {
          static Settings s; // Инициализируется ровно один раз на всю программу.
          return s;
      }
  };
  Settings s;  // Ошибка, приватный конструктор.
  ```

# Перегрузка операторов [00:20]
## Синтаксис [00:10]
* Напоминание: уже перегружали `operator=`.
* Ещё можно перегружать так же `operator+`, да и почти все (кроме `&`, `.`, `?:`, `::`).
  ```
  struct BigInt {
      BigInt operator+(const BigInt &other) const { // *this + other, можно вернуть что угодно.
      }
  }
  ```
* Даже `->`, это полезно для "умных указателей".
* Даже `,`, `&&` и `||` можно, но при перегрузке отрубается short-circuit.
* Альтернативный способ написать, если мы не хотим добавлять в класс:
  ```
  // Функция снаружи.
  BigInt operator+(const BigInt &a, const BigInt &b) {
      return ...
  }
  ```
* ```
  struct BigInt {
       BigInt& operator++(); // prefix ++x;
       BigInt operator++(int); // postfix x++;
  };
  ```
* Оператор приведения типа: `operator int() const`
  * Нужен, чтобы приводить к примитивным типам, у которых конструктор не можем написать.
* Операторы сравнения: реализуем `==` и `<`, остальные выражаются.
  Если производительность неважна, то только `<`.
  * В C++20 появляется `operator<=>`, который позволяет выразить сразу все шесть операторов.

## Удобная реализация и friend-функции
* Операторы сравнения: все вне класса, чтобы аргументы приводились к типу `BigInt`:
  ```
  bool operator==(const BigInt &a, const BigInt &b); // good
  bool BigInt::operator==(const BigInt &b); // не работает 2 < BigInt()
  ```
* Сначала `+=` внутри класса, потом `+` снаружи.
  Аналогично, плюс меньше обращений к приватным полям.
  ```
  BigInt operator+(BigInt a, const BigInt &b) {
      return a += b;
  }
  ```
* Чтобы можно было обращаться к приватным методам (если надо), внутри класса объявляем friend-функцию:
  ```
  friend bool operator==(const BigInt &, const BigInt &);
  ```
* Сначала prefix, потом postfix:
  ```
  BigInt& operator++() { ...; return *this; }
  BigInt operator++(int) { BigInt result = *this; this++; return result; }
  ```
