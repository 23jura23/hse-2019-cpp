# Исключения [00:20]
## Исключение в конструкторах (подобъекты и тело) [00:15]
```
struct Foo {
    std::vector<int> a, b;
    Foo(const std::vector<int> &_a, const std::vector<int> &_b) {
        a = _a;
        b = _b;
    }
};
```

* Если в процессе копирования вылетит исключение, то ничего страшного.
* Все поля при входе в конструктор созданы, при вылете исключения они
  будут автоматически уничтожены, равно как и сам `Foo`.
* Даже в конструкции `new Foo(...)` память, выделенная под `Foo`,
  будет освобождена.

Но лучше это написать как member initialization list:
```
struct Foo {
    std::vector<int> a, b;
    Foo(const std::vector<int> &_a, const std::vector<int> &_b)
        : a(_a)
        , b(_b) {}
};
```

* Тут исключение может вылететь ещё до входа в конструктор,
  в процессе инициализации полей.
* Если вылетело в `a(_a)`, то надо уничтожить только `Foo`,
  но `b` не трогать.
* Если вылетело в `b(_b)`, то надо уничтожить `a`, а потом `Foo`.
* Это всё автоматически.

Если хочется, можно эти исключения обрабатывать (но не отменять)
при помощи function try block:

```
struct Foo {
    std::vector<int> a, b;
    Foo(const std::vector<int> &_a, const std::vector<int> &_b)
    try
        : a(_a)
        , b(_b) {
    } catch (const std::bad_alloc&) {
        std::cerr << "Allocation failed" << std::endl;
        // Что угодно делаем, но в конце есть неявный `throw;`, объект не восстановить.
    }
};
```

При этом обращаться к полям нельзя, вот так не написать:

```
struct Foo {
    int *a, *b;
    Foo()
    try
        : a(new int[10])
        , b(new int[10]) {
    } catch (const std::bad_alloc&) {
        // Нельзя понять, какой из двух упал.
        // Даже если `b`, только нельзя обращаться к `a`.
    }
};
```

Вывод: везде используем RAII.
Тогда у нас будет basic guarantee.

Прям везде:
```
new X(new Y); // Если консуктор `X` кинул исключение, то `new Y` утёк.
```

## Исключения в деструкторах [00:03]
Если исключение вылетело из деструктора, то в C++ это `std::terminate`,
потому что все деструкторы неявно помечены как `nothrow`.

Это сделано, чтобы не думать, что делать с исключением, которое
вылетело при раскрутке стека.

## Тонкости [00:02]
* Иногда исключения в проектах запрещают полностью.
  Тогда сложно взаимодействовать со стандартной библиотекой.
  Причины:
  * Так сложилось исторически, код не был готов к исключениям.
  * Исключения могут быть не полностью zero-overhead.
* Если мы сделали `new Foo[10]`, и один из конструкторов кинул
  исключение, то надо ещё и предыдущие объекты удалить,
  а потом освободить память.
  Это делается автоматически.

# Шаблоны [00:15]
## Решение в стиле Си [00:10]
```
class IntArray {
private:
    int *data;
public:
    ...
};
```
В случае Си можно было бы генерировать такие классы препроцессором:
```
// my_array.h
#define MyArray(TYPE) class MyArray_##Type { \
private: \
    TYPE *array; \
    size_t size; \
public: \
    ... \
}
```
Здесь ``\` — перенос строки в макросе, а `##` — конкатенация токенов.
Использовать так:

```
#include "my_array.h"
MyArray(int);
MyArray(double);

MyArray_int a;
```

В чём проблемы:

* Некрасиво выглядит исходник.
* Некрасивые сообщения об ошибках.
* Плохо работает с namespaces: `MyArray(details::Foo)` не скомпилируется.

## Шаблонные классы [00:10]
```
template<typename T>
class MyArray {
private:
    T *data;
    size_t size;
public:
    T& get(size_t i) { return data[i]; }
};
```
или
```
template<typename T>
T& MyArray<T>::operator[](size_t i) { return data[i]; }
```

* Здесь `MyArray` — шаблон, а `MyArray<int>` — класс.
* Все `MyArray<???>` абсолютно независимые.
* Компилируется методом "скопировали токены, заменили `T` на указанный тип".
  * Нет проблем с именами.
* Шаблон проверяется только на базовую синтаксическую корректность
  (скобочки сошлись), но не компилируется, пока не потребуется.
* Так как работает потенциально с любым типом,
  все реализации должны быть в `.h`.
* Можно несколько типовых параметров, можно `class T` вместо `typename T` (синонимы).
* До C++11 нельзя было писать `vector<vector<int>>`, потому что `>>` похоже на битовый сдвиг.
* Внутри класса можно не писать типовой параметр, он будет по умолчанию такой же:
  ```
  class MyArray {
      MyArray(const MyArray& other) : data(...), size(...) { ... }
  };
  ```

## Шаблонные функции [00:05]
```
template<typename T>
void print(const MyArray<T> &arr) {
    for (size i = 0; i < arr.size(); i++)
        std::cout << arr[i] << std::endl;
};
// ...
MyArray<int> a = ...;
print<int>(a);
```
Если из параметров выводится `T`, то можно не писать: `print(a)`.

Получаем этакий pattern matching.

## Функторы [00:10]
Стандартный трюк: вместо функции передаём объект.
Тогда на этапе компиляции inline.
А вместе с автовыводом типов вообще хорошо.

## Лямбды?

# Вектор
## Placement new, явный вызов деструктора
## Выделение выровненной памяти, alignof
## Трудности с конструктором копирования и исключениями из пользовательских типов
## Трудности с operator=
## Нет трудностей с copy-and-swap, заодно строгая гарантия
