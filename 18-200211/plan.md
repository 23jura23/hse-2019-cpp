# Исключения [00:30]
## Исключение в конструкторах (подобъекты и тело) [00:20]
```
struct Foo {
    std::vector<int> a, b;
    Foo(const std::vector<int> &_a, const std::vector<int> &_b) {
        a = _a;
        b = _b;
    }
};
//
std::vector<int> x, y;
try {
    Foo f(x, y);
    // ...
} catch (const std::bad_alloc&) {
    // ...
}
```

* Если в процессе копирования вылетит исключение, то ничего страшного.
* Все поля при входе в конструктор созданы, при вылете исключения они
  будут автоматически уничтожены, равно как и сам `Foo`.
  * Деструктор `Foo` при этом не вызывается, так как конструктор не завершился!
* Даже в конструкции `new Foo(...)` память, выделенная под `Foo`,
  будет освобождена.
  ```
  try {
      Foo *f = new Foo(x, y);  // Утечек не будет
      // throw ....; // Утечёт `Foo *f`, а из `catch` его уже не достать.
  } catch (const std::bad_alloc&) {
  }
  ```
  * Поэтому стоит использовать `unique_ptr<Foo>` — это "умный указатель",
    который автоматически удалит свой аргумент.
  * Надо аккуратно: `unique_ptr<Foo> f(new Foo)`, но `unique_ptr<Foo[]> f(new Foo[10]);`,
    чтобы вызвался верный `delete`/`delete[]`.
  Правда, от конструкции `new Foo(...)` становится 

Но лучше это написать как member initialization list:
```
struct Foo {
    std::vector<int> a, b;
    Foo(const std::vector<int> &_a, const std::vector<int> &_b)
        : a(_a)
        , b(_b) {}
};
```

* Тут исключение может вылететь ещё до входа в конструктор,
  в процессе инициализации полей.
* Если вылетело в `a(_a)`, то надо уничтожить только `Foo`,
  но `b` не трогать.
* Если вылетело в `b(_b)`, то надо уничтожить `a`, а потом `Foo`.
* Это всё автоматически. Деструктор `Foo` всё ещё не вызывается!

Если хочется, можно эти исключения обрабатывать (но не отменять)
при помощи function try block:

```
struct Foo {
    std::vector<int> a, b;
    Foo(const std::vector<int> &_a, const std::vector<int> &_b)
    try
        : a(_a)
        , b(_b) {
    } catch (const std::bad_alloc&) {
        std::cerr << "Allocation failed" << std::endl;
        // Что угодно делаем, но в конце есть неявный `throw;`, объект не восстановить.
    }
};
```

При этом обращаться к полям нельзя, вот так не написать:

```
struct Foo {
    int *a, *b;
    Foo()
    try
        : a(new int[10])
        , b(new int[10]) {
    } catch (const std::bad_alloc&) {
        // Нельзя понять, какой из двух упал.
        // Даже если `b`, только нельзя обращаться к `a`.
    }
};
```

Вывод: везде используем RAII.
Тогда у нас будет basic guarantee.
Хотели чистый указатель — лучше `unique_ptr` или `vector`.

Прям везде:
```
new X(new Y); // Тут `X` начинает владеть `Y` и обязан его удалить, "очевидно".
```

1. Если кинул конструктор `Y`, то утечек нет.
2. Если кинул конструктор `X`, то утечек нет — он может удалить переданный во владение `Y`.
3. Если кинул исключение `new Y`, то утечек нет.
4. А вот если исключение кинул `new X`, то утекло `new Y`. До конструктора `X` дело не дошло.

Как лечить: давайте `X` сам создаст себе `Y`.
Или передадим ему `std::make_unique<X>(std::make_unique<Y>());` (с C++14), заодно
явно обозначим, что `X` получает именно владение.

## Исключения в деструкторах [00:05]
Если исключение вылетело из деструктора, то в C++ это `std::terminate`,
потому что все деструкторы неявно помечены как `nothrow`.

Это сделано, чтобы не думать, что делать с исключением, которое
вылетело при раскрутке стека.

## Тонкости [00:05]
* Иногда исключения в проектах запрещают полностью.
  Тогда сложно взаимодействовать со стандартной библиотекой.
  Причины:
  * Так сложилось исторически, код не был готов к исключениям.
  * Исключения могут быть не полностью zero-overhead.
  * Несовместимость ABI: если библиотека не поддерживает, может быть упс.

# Шаблоны [00:34]
## Решение в стиле Си [00:05]
```
class IntArray {
private:
    int *data;
public:
    ...
};
```
В случае Си можно было бы генерировать такие классы препроцессором:
```
// my_array.h
#define MyArray(TYPE) class MyArray_##Type { \
private: \
    TYPE *array; \
    size_t size; \
public: \
    ... \
}
```
Здесь ``\` — перенос строки в макросе, а `##` — конкатенация токенов.
Использовать так:

```
#include "my_array.h"
MyArray(int);
MyArray(double);

MyArray_int a;
```

В чём проблемы:

* Некрасиво выглядит исходник.
* Некрасивые сообщения об ошибках.
* Плохо работает с namespaces: `MyArray(details::Foo)` не скомпилируется.

## Шаблонные классы [00:17]
```
template<typename T>
class MyArray {
private:
    T *data;
    size_t size;
public:
    T& get(size_t i) { return data[i]; }
};
```
или
```
template<typename T>
T& MyArray<T>::operator[](size_t i) { return data[i]; }
```

* Здесь `MyArray` — шаблон, а `MyArray<int>` — класс.
* Все `MyArray<???>` абсолютно независимые.
* Компилируется методом "скопировали токены, заменили `T` на указанный тип".
  * Нет проблем с именами.
* Шаблон проверяется только на базовую синтаксическую корректность
  (скобочки сошлись), но не компилируется, пока не потребуется.
* В момент первого использования шаблон _инстанцируется_ в конкретный класс и происходит компиляция.
  Тут уже можно получить несоответствия типов, не найденные перегрузки функций...
  * Инстанцируется отдельно: все поля класса (когда пытаемся создать объект), методы (когда
    вызываем конкретный метод; то есть какие-то методы могут для некоторых типов не работать).
* Так как работает потенциально с любым типом,
  все реализации должны быть в `.h`.
* Можно несколько типовых параметров, можно `class T` вместо `typename T` (синонимы).
* До C++11 нельзя было писать `vector<vector<int>>`, потому что `>>` похоже на битовый сдвиг.
* Внутри класса можно не писать типовой параметр, он будет по умолчанию такой же:
  ```
  class MyArray {
      MyArray(const MyArray& other) : data(...), size(...) { ... }
  };
  ```

## Шаблонные функции [00:10]
```
template<typename T>
void print(const MyArray<T> &arr) {
    for (size i = 0; i < arr.size(); i++)
        std::cout << arr[i] << std::endl; // Проверка существования << только в момент инстанцирования.
};
// ...
MyArray<int> a = ...;
print<int>(a);
```
Если из параметров выводится `T`, то можно не писать: `print(a)`.
Компилятор решит уравнение на типы.
Получаем этакий pattern matching.

Если есть несколько перегруженных функций, то компилятор в каждой перегрузке решит
уравнение, если не получилось - выкинет из кандидатов, а среди выживших
проведёт конкурс "кто лучше подоходит под параметры".

Можно писать несколько `typename`, они работают как параметры у функций:
в угловых скобках всегда идут слева направо, даже если какой-то можно вывести
автоматически или указано значение по умолчанию (`typename U = int`).
`template<typename T, typename U> void foo(T x);` и `foo<int>(10)` не вызовется:
мы явно сказали `T=int`, а для `U` информации не хватает.

А вот `template<typename T, typename U> void foo(U x);` и `foo<void>(10)`
уже вызовется: `T=void` явно, `U` вывели сами.

## В шаблонах код копируется, не как в generic'ах [00:02]

# Функторы [00:07]
Напишем `sort` на плюсах:
```
template<typename T>
void sort(Array<T> &arr, int (*cmp)(const T&, const T&));
```
теперь нет вообще указателей и правильный тип у компаратора.

Лирическое отступление: в плюсах обычно не такой компаратор,
а `operator<` (возвращает `bool`: строго меньше или нет).

Но есть проблема, если хотим stateful компаратор: например,
посортировать по `a * x`, где `x` — константа.
Глобальной делать нехорошо.

Стандартный трюк: вместо функции передаём объект:
```
struct Comparator {
    int x;
    bool operator()(int a, int b) {
        return a * x < b * x;
    }
};
//
Array<int> arr = ...;
Comparator c;
c.x = 10;
// template<typename T, typename Cmp> void sort(Array<T> &arr, Cmp cmp);
sort<int, Comparator>(arr, c);
// с автовыводом типом:
sort(arr, c);
```

Тогда на этапе компиляции inline вообще всего.
И нет никаких виртуальных вызовов или чего-то такого.

## Лямбды [00:08]
Такие компараторы писать хочется на удивление часто, но это много кода.
Можно, конечно, конструктор добавить: `sort(arr, Comparator(10));`, но всё равно надо создавать класс отдельно.

С лямбдами можно писать так:
```
sort(arr, [x](int a, int b) { return a * x < b * x; });
```
Тип лямбды (анониминый класс) неизвестен, поэтому тут важен автовывод.

Те переменные, что в квадратных скобках, запоминаются-копируются в лямбду в момент создания ("захват по значению").

Возвращаемый тип лямбды выводится автоматически.
Но можно дописать, если хочется: `[](int a, int b) -> bool { return a < b; }`.
Внутри можно писать любой код.

Пример пустой бесполезной лямбды, которую сразу вызываем: `[](){}();`.

Ещё можно захватывать переменные по ссылке, но тогда надо, чтобы лямбда не вызывалась,
когда переменные сдохнут: `[&x](int a, int b) { return a * x < b * x; }`.

Можно захватить несколько: `[a, &b]`, скопировать всё `[=]`, захватить по ссылке всё `[&]`.

Это всё прекрасно оптимизатором встраивается на этапе компиляции.
