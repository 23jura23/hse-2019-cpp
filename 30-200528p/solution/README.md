# Инструкция

1. Решайте задания по номерам: от `01` и далее.
2. Внутри каждого задания раскомментируйте и проходите тесты по очереди.
    * В задании `03_concat_separated` остановитесь перед тестом `TEST_CONCAT_SEPARATED_04_TUPLE` и перейдите к следующему заданию.
    * В задании `04_memorizer` остановитесь перед тестом `TEST_MEMORIZER_07_MEMORIZER_SPECIFIED_ARG_REFS`  и перейдите к следующему заданию.
3. Если вы успели дойти до `04_memorizer` (неважно, успели ли попробовать даже первый тест) — это уже очень хорошо.

# Советы
## `02_concat`
1. Попробуйте два вида fold expression и трюк с dummy array.

## `03_concat_separated`
1. В C++11 будет удобно написать вспомогательную рекурсивную функцию.
1. В C++17 будет удобно воспользоваться fold expression оператора `,` с шаблонной лямбдой, которая захватывает все параметры.
1. Тест `TEST_CONCAT_SEPARATED_04_TUPLE` существенно сложнее всех предыдущих.
1. В тестах `*TUPLE*` попробуйте выразить новую перегрузку через уже написанные, чтобы потренироваться с:
    * `std::apply` для вызова функции от кортежа
    * `std::tuple_cat` для конкатенации кортежей
    * `static_cast<>` для получения указателя на конкретную перегрузку функции

## `04_memorizer`
1. В тесте `TEST_MEMORIZER_03_MEMORIZER_COPIES_ARGS`
   будьте осторожны с порядком вычислений аргументов внутри `()` — он не определён. Это может не ловиться автоматическими тестами.
1. В тесте `TEST_MEMORIZER_06_MEMORIZER_DEDUCTION_NO_REFS`
   вам может потребоваться `std::remove_reference_t`.
1. В тесте `TEST_MEMORIZER_07_MEMORIZER_SPECIFIED_ARG_REFS`:
   * Будьте осторожны: там не нужен perfect forwarding, там нужно копировать аргументы.
     Возможно, вам потребуется добавить ещё один конструктор в `CallLog`.
   * Вам может потребоваться `std::remove_reference_t`.
   * Если вы создаёте переменную внутри функции, не забудьте её замувать при необходимости.
1. В тесте `TEST_MEMORIZER_08_MEMORIZER_SPECIFIED_RET_REF`
   может оказаться удобным объявить переменную как `decltype(auto) x = ....;`

## `05_zip`
1. Используйте `std::make_index_sequence`, чтобы получить последовательность чисел от `0` до `N-1` внутри некоторого типа.
1. Используйте одну из двух техник, чтобы получить готовый к раскрытию parameter pack из типа `std::index_sequence`:
    * Вспомогательная структура и её специализация для `std::index_sequence<Indices...>`.
    * Вспомогательная (лямбда-)функция и фиктивный параметр типа `std::index_sequence<Indices...>`.
