# Разбор теста [00:10]
1. Стэк маленький, может переполниться, будет UB.
   Неверно: чтобы программа не упала (переполнение стэка — это UB), для ускорения (доступ к памяти так не предсказать; выделение в куче сильно медленнее выделения в стеке).
2. Выделяет большой объект на стеке.
   Неверно: долго работает, не использует n (там есть многоточия), вызывает себя рекурсивно, массив недоступен после выхода из функции (та же самая проблема есть у локальных переменных).
3. Выделяет небольшой массив в куче, это долго и/или усложняет код. Можно на стеке или выделить/освободить один раз.
   Частично верно: "Выделяем массив много раз, можно вынести".
   Неверно:
    * Нужно прикастить malloc (в Си не нужно, это была исправленная ошибка в лекции)
    * Может быть ошибка внутри bar (тогда падает всё, исключений в Си нет)
    * bar может изменить указатель (не может), код ничего не делает (bar может что-то делать).
   Ещё не хватает `;` после `free` и не проверяется `NULL`.
4. Неверно: использование sizeof для длины строки.
5. Популярные ошибки:
    * Не обработан NULL после первого strchr
    * "Нет +1 к результату первого strchr
6-7. Выделяем сначала память для всех данных, потом массив указателей.

# swap trick с безымянной переменной [00:05]
```
BigInt& operator=(BigInt other) {
    other.swap(*this);
}
BigInt& operator=(const BigInt &other) {
    BigInt tmp = other;
    tmp.swap(*this);
}
BigInt& operator=(const BigInt &other) {
    BigInt(tmp).swap(*this);
}
```
Надо писать так, как в начале.
Чуть точнее выражает намерения.
А ещё можно `swap` отключить для временных значений,
потому что это разве что для этого трюка и годится.

# Парочка UB [00:05]
* Никогда не начинайте название переменной с нижнего подчёркивания!
  http://codeforces.com/blog/entry/17747
* `(void*)123` — плохая идея для передачи числа.

# Умные указатели  [00:20]
"Лекция 09. Перегрузка операторов. Умные указатели", страницы 17-21.

# Наследование [00:50] (а есть всего [00:30])
## Наследование реализации [00:15]
Одна из идей: можно писать классы на основе существующих.

Был класс:
```
struct Queue {
private:
    IntList data;
public:
    Queue();
    Queue(const IntArray &init_values);
    void push(int x);
    void pop();
    int front() const;
    bool empty() const;
};
```
Хотим добавить метод `length()`, но этот класс менять не хотим.
Сделаем новый!
Теперь есть "базовый класс/предок/суперкласс/base class" и "производный класс/потомок/derived class".
```
struct SizedQueue : public Queue {
private:
    size_t len;
public:
    // data не виден! Поэтому вызываем push() из родителя.
    void push(int x) { len++; /*Queue::*/push(x); }
    void pop() { len--; /*Queue::*/pop(x); }
    size_t length() const { return len; }
};
```
Здесь мы сказали компилятору:
1. Добавь нам все поля и методы из `Queue`
   и обрежь их видимость до `public` (можно написать `private`,
   тогда у нас будут все методы и поля, это иногда полезно).
2. Ещё вот такие-то методы перекрой (override): имя то же,
   параметры те же, код другой.
   Они могут звать родительские методы (а как, кстати, если уже
   перекрыты?).
3. Остальные методы (например, `front()`) не перекрыты.
   "Наследуются": используются версии из `Queue`.

Теперь в коде `Queue a; SizedQueue b; a.push(10); b.push(10)`
будет зваться разный `push`.

Этот выбор происходит на этапе компиляции: компилятор видит тип
переменной `a`/`b` и вызывает нужный код.

Ещё можно случайно сделать перегрузку (overload), вообще новый метод,
название то же, но новые параметры:
```
void push(int x, int y) { ... }
```

## protected [00:05]
* Появляется промежуточный между `private` и `public`: `protected`.
  Говорит "доступ только у меня __и__ моих наследников".
* Например, в `SizedQueue` можно было бы `len` сделать `protected`.
* Важно: про `protected`-интерфейс тоже надо думать и как-то гарантировать!
  Я рекомендую по умолчанию им не пользоваться.

## Проблемы наследования реализации [00:05]
1. Если забыли перекрыть, то упс.
1. Если в родителе появился новый метод, который мы забыли перекрыть, то упс.
1. Если родитель сам где-то вызывал `push`/`pop`, то это место надо раскопировать.
   Например, в методе `front_and_pop()`.
1. Про protected тоже надо думать!

## Конструкторы в наследовании [00:05]
Конструкторы не наследуются, потому что нужно ещё как-то
проинициализировать поля наследника.
```
SizedQueue() {}
SizedQueue(const IntArray &init_values) {
    Queue(init_values);  // Wrong!
    Queue::Queue(init_values);  // Wrong!
}
SizedQueue(const IntArray &init_values) : Queue(init_values) {  // Ok!
}
```
Базовый класс инициализируется до всех полей.

Деструкторы базового класса вызываются автоматически в конце нашего.
Явно вызывать не надо.
```
~SizedQueue() {}
```

## Расположение в памяти [00:10]
* В начале располагается базовый класс, а потом новые поля.
* Тогда конвертация указателей не требуется: можно использовать
  указатель на `SizedQueue*`, как указатель на `Queue*`.
  Прям неявно:
  ```
  SizedQueue *a = ...;
  Queue *b = a;
  SizedQueue *c = (SizedQueue*)b;  // Надо точно знать
  ```
* Что будет работать у `b`: `front`
* Что будет работать у `b`, но неправильно: `push`, `pop` (не обновляют `length`).
  С этим разберёмся на следующей лекции.
* Аналогично со ссылками.

## Нарезка (slicing) [00:05]
* Из-за ссылок в конструктор копирования (даже по умолчанию) можно передать наследника:
  ```
  Queue(const Queue &other) { ... }
  ```
* Тогда во фразе `SizedQueue a; Queue b = a` в `b` окажется копия `a`, которая забыла
  свою длину.
* Вроде ничего страшного, но нарезка (slicing) происходит молча:
  ```
  void foo(slow_queue q);
  fast_queue q;
  foo(q); // Ой, нарезка.
  ```

## Вывод [00:05]
Наследование — это инструмент, иногда полезный (особенно со следующей лекции),
но просто его использовать для экономии места не стоит, можно огрести с нарезкой.
