# Система типов [00:40]
## Общее [00:05]
* Что такое "переменная"? Моё определение: кусок памяти, которому дали имя.
  Это не совсем точно, потому что переменная в процессе компиляции и оптимизации может полностью исчезнуть, ну да ладно.
* Что такое "тип переменной"? Моё определение: это пара: (какие значения могут храниться в переменной, какие операции можно с ней выполнять).
* Базовое разделение бывает просто по значениям переменной: числа целые, вещественные, строчки, массивы.
* Зачем это надо: чтобы компилятор знал, что конкретно на уровне байт делать, когда пишем
  `a = b * 2`, для целых и вещественных это разное.
* Компилятор может проверять типы на этапе компиляции и запрещать некорректные операции,
  даже если им можно придумать смысл (или несколько):
  ```
  int a = 10;
  char *x = a;
  ```
  Или как-то хитро генерировать код:
  ```
  double d = 1.2;
  int x = d;  // Скомпилируется, округление к нулю автоматически.
  ```
* Так что можно в типах записывать не только "сколько байт и как кодируется", но и добавлять
  дополнительные ограничения.
  Пример из физики: на C++ можно сделать типы "метр", "секунда", "метр в секунду" и компилятор будет проверять размерность:
  ```
  meter distance = 10m;
  seconds time = 10s;
  mps speed1 = 2 * distance / time;
  mps speed2 = time / distance;  // Compilation error.
  mps speed3 = 10.0;  // Compilation error.
  ```

## const у переменной [00:15]
* Зачем: говорим, что значение установлено один раз и менять нельзя.
  Компилятор проверит и убедится, что мы нигде случайно не ошиблись.
  * Математическая константа: `const double PI = 3.1415;`
  * Константы для задачи:
    ```
    const int dx[] = { 1, 0, -1, 0 };
    const int dy[] = { 0, 1, 0, -1 };
    ```
* Есть и в Си, и в С++ (ошибка с прошлой лекции).
  Отличие в том, что в C++ константы можно использовать для размера массива и ещё некоторых случаев, а в Си — нет:
  ```
  const int N = 10;
  int arr[N];
  ```
  https://stackoverflow.com/a/5249001/767632
* Альтернативный синтаксис: `double const PI = 3.1415;`, тогда "`const` защищает то, что слева".
* Не любой `const` компилятор может вычислить на этапе работы программы и встроить.
  Можно делать глобальные, а можно делать локальные, и даже параметры:
  ```
  void solve(const int w, const int h) {
      const int area = w * h;
      // ...
      printf("%d\n", answer);
  }
  int main() {
      int w, h;
      while (scanf("%d%d", &w, &h) == 2) {
          solve(w, h); // Константность требуется только у копии внутри solve()
      }
  }
  ```
  Тут мы не можем забыть "пересчитать" `area`, потому что она зависит только
  от `w` и `h`, которые нельзя поменять.
  А если уж очень надо — то, наверное, это вообще начался новый тест, так что
  надо пересчитать вообще всё. И поэтому лучше делать это в функции, а не в
  глобальных переменных, чтобы компилятор мог проверить.

## const у указателя [00:15]
* Указатель на константную память.
  Пример — строковой литерал. Указывает на кусок памяти, в котором хранится код программы, менять его нельзя.
  ```
  const char *s1 = "hello";
  s1[0] = 'H';  // Compilation error
  char *s2 = "world";  // Compilation error в C++, в Си это окей, потому что const не сразу был.
  s2[0] = 'w';  // UB в Си (runtime)
  ```
* Альтернативный синтаксис: `char const *s1`, тогда "`const` защищает то, что слева".
  Или: разыменовали `s1`, получили `char const`.
* При этом сам указатель можно менять:
  ```
  const char *s1 = "hello";
  *s1; // 'h'
  s1 = s1 + 2;
  *s1; // 'e'
  ```
* Можно сделать константный указатель, который менять нельзя:
  ```
  char arr[10] = "hello";  // Специальный синтаксис "скопируй строчку в локальный массив".
  char *const s1 = arr;
  *s1 = 'H';  // OK
  s1 = s1 + 2;  // Compilation error.
  ```
  Тут `const` защищает "то, что слева", то есть `*`, указатель.
  * Можно читать так: `s1` можно разыменовать, но он сам по себе `const`.
  * cdecl.org
* Путаница с терминологие: иногда говорят "константный указатель", подразумевая указатель на константную память.
* А можно совместить:
  ```
  char const *const s1 = "hello";
  *s1 = 'H';  // Compilation error.
  s1 = s1 + 2;  // Compilation error.
  ```
* Есть стиль, в котором все переменные делаются константными.
  Но тогда надо много-много функций, которые бегают по массивам, считают частичные суммы
  и прочее, это называется "функциональный стиль", в нём довольно приятно писать,
  если есть хорошая библиотека.

# Универсальная сортировка [00:15]
Это будет в домашке.
Напомню сигнатуру:

```
void sort(void *data, int elements, size_t element_size, int (*compare)(void*, void*));
```
Что означает каждый параметр?
Давайте напишем пример вызова:

```
int arr[10];
sort(arr, 10, sizeof(int));
sort(arr, 10, sizeof arr[0]);
sort(arr, sizeof arr / sizeof arr[0], sizeof arr[0]); // Осторожно!
int *parr = arr;
sort(arr, sizeof parr / sizeof parr[0], sizeof parr[0]); // Осторожно!
```

Куда можно добавить `const` в сигнатуре?

```
void sort(const void *data, int elements, size_t element_size, int (*compare)(const void*, const void*));
```

При этом добавлять `const` к самим параметрам не надо.
Это часть реализации функции, а не сигнатуры.
Скомпилируется, всё окей, но не надо.

И к возвращаемому значению не надо, потому что оно всё равно скопируется в отдельную переменную.

```
void sort(const void *const data, const int elements, const size_t element_size, int (*const compare)(const void*, const void*)) {
}
```

# Стандартная библиотека [00:25]
TODO
## Зачем стандартная библиотека [00:05]
В любом уважающем себя языке есть сам язык, а есть стандартная библиотека.
Разные ОС, разные системные вызовы.
Всякие полезные штуки вроде математики или форматирования вывода, которые много где используются.
В Си есть `libc`, она же есть ещё много где.
Есть реализации вроде `glibс`.

Эта же библиотека включается и в C++, но там ещё и своя есть.
См. cppreference.com, cplusplus.com, MSDN.
Все должны более-менее совпадать.

Ещё бывают расширения конкретного компилятора (и к языку, и к библиотеке).

Где живёт, какие заголовки подключать?

## Обзор полезных [00:03]

## stdio: FILE* [00:02]
`fopen`, что внутри, opaque, константность указателя, `fclose`, что иначе.

## Текстовые и бинарные файлы [00:03]

## Чтение и запись текстовых файлов [00:05]

## Чтение и запись бинарных файлов [00:07]
