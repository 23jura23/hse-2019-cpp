# Вопросы/ошибки из теста [00:10]
## Задание 1 [00:05]
* Основное: `a`/`b`/`c` неотличимы. Это всё переменные типа `int`, у них одинаковый тип и категория (lvalue).
  * Это самое главное в этом задании! Нельзя смотреть на наличие ссылок в объявлении, если ты не `decltype`!
* `u` компилируется от чего угодно.
* `w` требует себе lvalue. От переменных окей, от `std::move` не окей. Тут много разногласий.
* `x` компилируется от чего угодно. Были сомнения с `std::move` и `c`.
* `y` требует себе rvalue. В частности, от `c` нельзя.

## Остальные задания [00:05]
* В 2 и 3
  * `move` из переменных делать надо
  * `move` от вызова функции функции делать не надо
  * `move` при возврате переменной при помощи `return` не надо (даже в C++11),
    а с C++17 там даже не нужен мув конструктор: https://stackoverflow.com/questions/4316727/returning-unique-ptr-from-functions/4316948#4316948
* В 4
  * Не нужны никакие касты! Не `const_cast`, а `void use() const`. Да и вообще неконстантный указатель можно передать вместо константного.
* В 5
  * Тонкая ошибка: `const S&&` — это не move constructor.
  * Даже rvalue-ссылка — это ссылка!

# Свойства выражений [00:35]
## Самостоятельное определение свойств типов через SFINAE
Задача: хотим понять, есть ли у `T` метод `begin`, принимает ли ноль аргументов, возвращает ли `typename T::iterator`.
Или хотим проверить, есть ли тип `iterator`.

### SFINAE [00:05]
http://jguegant.github.io/blogs/tech/sfinae-introduction.html

* Substitution Failure Is Not An Error.
  * Пример с `typename T::iterator` в параметре или возвращаемом значении.
* Работает только в сигнатуре, не работает в параметрах по умолчанию и теле функции (там "hard error").
* Работает в template alias.
* Работает только на один уровень: если сделать свою структуру, а внутри `using`, то он должен быть нормальным.
  * Есть разница между `foo_v<X>` и `foo<X>::value`: в первом случае hard error, во втором SFINAE из-за отсутствия value.
* Не работает, если параметр не шаблонный у самой функции: например, у методов шаблонного класса.
  Надо, чтобы подстановка была "здесь и сейчас".

### Проверка корректности выражения в общем случае через оператор "запятая" и `declval` (C++11) [00:05]
* Идея:
  * Создать две перегрузки функции (даже без реализаций): одна выкинется по SFINAE, другая низкоприоритетная.
  * Узнать, какая перегрузка выбирается от определённых параметров, сделать вывод.
* Детали по шагам:
  * Низкоприоритетная перегрузка — `foo(...)` (здесь это ellipsis, часть синтакиса, наследие Си).
  * Выкидывать по SFINAE можно через `,` в `decltype()` в возвращаемом значении.
    Там можно просто вызвать нужный `begin()`.
  * В C++11 можно просто написать `constexpr` функцию, которая возвращает `true`/`false`.
  * Осторожно с шаблонным параметром у `test<T>()`: обе перегрузки должны быть шаблонными.
    Либо делать фиктивный первый параметр, чтобы `T` вывелось.
* Это мы проверили, что есть `begin()`, но не проверили возвращаемый тип.
	
### Проверка типа выражения через `is_same`+`enable_if` [00:05]
* Если нам надо ещё и проверить тип выражения, то у нас есть `is_same_v<decltype(...), Foo>`.
  Но это `bool`.
  Надо в зависимости от его значения либо SFINAE, либо `bool`.
* Получаем `enable_if_v<is_same_v<....>, bool>`
* ПОТОМ: это стандартный способ для выкидывания перегрузок, даже вне member detector.

### Проверка существования вложенного типа с `decltype` [00:03]
* Если мы хотим не выражение, а просто тип, используйте `declval<T>`.
    
### До C++11 без `declval`/`decltype` через `sizeof`: Member Detection Idiom [00:10]
* Мы всё ещё можем сделать `enable_if`/`is_same`, но уже не можем делать `decltype`/`declval`/`constexpr`.
  * Теперь функция возвращает не `bool`, а тип (`true_type`/`false_type`).
    Но мы не можем их отличить, у нас только `sizeof`. Надо заменить на `struct yes`/`struct no` с разным размером.
    * Таким образом можем переходить из типов в `bool` и обратно.
  * Большая проблема: возвращаемый тип. Там нам принципиально написать выражение с запятыми, чтобы взять `decltype`.
    Теперь в общем случае удобно определить тип выражения не можем.
* Но мы всё ещё можем определить, что есть вложенный тип:
  * Передали параметр типа `typename T::iterator*` и `nullptr`.
* И всё ещё можем определить, что есть член (функция или поле) с определённым типом.
  * Попробуем добавить параметр типа `typename T::const_iterator (T::*)() const` и передать туда `begin()`.
  * Это будет hard error в момент вызова `&T::begin`.
    * Кстати, если случайно забыть один из двух `const`, будет hard error "не удаётся найти адрес перегруженной функции", а не более внятная.
  * Решение: надо вызвать `&T::begin` где-то в сигнатуре (и не в значении по умолчанию).
    Надо кому-нибудь передать как шаблонный параметр.
    Ура, делаем `template<typename T, typename T::const_iterator (T::*)() const> struct Helper { typedef void type; };`,
    который заодно тип проверит.
    * Кстати, если случайно забыть один из двух `const`, будет просто 0. Как и ожидалось.
  * Более общий способ: `template<typename T, T> struct Helper { typedef void type; };`.

## C++20, анонс: концепты с requires expression (typename, проверка типов) [00:05]
"Концепты: упрощаем реализацию классов STD Utility" от Андрея Давыдова: https://habr.com/ru/company/jugru/blog/467299/

На самом деле в C++20 есть специальный requires expression (типа как оператор `noexcept`), который позволяет
писать без SFINAE на С++-подобном языке:
```
requires(const T &t) {
    typename T::iterator;
    t.begin();  // Можно ещё { t.begin() } -> IsSame<typename T::iterator>;
}
```

# Проверка "что нам подсунули" [00:25]
Теперь мы умеем что угодно понимать про типы. Давайте научимся с этим знанием что-нибудь делать.

## `static_assert` [00:03]
* Можно сказать `static_assert(std::is_move_assignable<T>, "optional message");`.
* Вообще в любом месте файла, даже вне функций и внутри класса.
  Например, вектору нужен перемещаемый тип. Если это не так, посыпятся странные сообщения. А так будет норм.
* Рекомендую писать сообщения.

## Включение-выключение
### Типов (специализация по условию) [00:05]
* Задача: специализация по условию. Например, для всех `is_integral_v<T>`.
* Идея: в специализациях и в параметрах шаблона по умолчанию тоже работает SFINAE.
* Давайте добавим в шаблон фиктивный параметр (к сожалению, это надо сделать: https://github.com/emscripten-core/emscripten/pull/9089/files )
* А теперь пишем специализацию для `Foo<T, enable_if_T<cond<T>>`: мы второй параметр делаем либо `void`, либо SFINAE.

### Перегрузок
TODO: перечитать ниже.

#### Основное [00:03]
* А зачем выключать перегрузки?
* Чтобы работали всякие `is_move_constructible` — они смотрят только на объявление, не определение.
* Напоминаю, что это всё SFINAE, поэтому требует себе шаблонный параметр от самой функции.
  Чтобы подцепить параметр от класса, надо `typename U = T`.

#### `enable_if_t` в возвращаемом значении, `auto ->` [00:04]
* Базовый трюк: сделали над возвращаемым значением `enable_if_t` по условию.
* Или, чтобы не писать свой member detector, можно сделать его прямо там: `auto foo(T a) -> decltype(a.foo()) { return a.foo(); }`.
  Можно в макрос обернуть.

#### `typename = enable_if_t` и `enable_if_t<...>* = nullptr` [00:05]
* Альтернативные места для пихания SFINAE (например, для конструкторов):
  * Фиктивный параметр со значением по умолчанию вида `enable_if_t<>* = nullptr`.
    Можно в параметрах, можно в шаблоне.
    * А ещё можно `void_t<>* = nullptr`, если просто проверить корректность выражения.
  * Шаблонный параметр (иначе у нас просто SFINAE не работает), как в структурах.

## C++20, анонс [00:05]
https://habr.com/ru/company/jugru/blog/467299/
### Terse syntax для ограничений над auto
* Переменные
* Параметры
* Возвращаемые типы

### Requires clause
* Можно писать вместо `enable_if`.
* Работает примерно так же, только сообщения об ошибках лучше (впрочем, clang и раньше разбирал `enable_if`).

# Адаптируемся под то, что подсунули [00:15]
## `if constexpr`
* Раньше делали через специализацию структур и вспомогательную функцию
* Например, для выбора стратегии копирования в векторе: создавать третий буфер или нет.

### `static_assert(false)`
* Будет всегда падать, даже внутри `if constexpr`.
* Надо обмануть компилятор: TODO

### Копирование векторов без третьего буфера

## Включение-выключение для выбора поведения
* Деструкторы нельзя выбирать через SFINAE, к сожалению. Только наследованием.
* Тонкость: https://stackoverflow.com/a/31138725/767632
  * Если так выбирать между перегрузками, то надо, чтобы отличались типы функций,
    без учёта значений по умолчанию.
    Поэтому `typename = enable_if_t` не сработает (получим тип `void`),
    а вот `enable_if_t<..>* = nullptr` сработает всегда.

## Свой `std::conditional` и выбор разных типов.
### `move_if_noexcept`
### Если дали геттер — верни `const&`, ещё и сеттер — `&`
### Выбор полей и родителей класса через наследование.
* Например, когда у нас тип — `void`. Можно ещё свою обёртку сделать, которая занимает один байт, и её специализировать.

## tag dispatching (уже был)
