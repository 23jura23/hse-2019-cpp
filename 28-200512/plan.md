# Вопросы/ошибки из теста [00:10]
## Задание 1 [00:05]
* Основное: `a`/`b`/`c` неотличимы. Это всё переменные типа `int`, у них одинаковый тип и категория (lvalue).
  * Это самое главное в этом задании! Нельзя смотреть на наличие ссылок в объявлении, если ты не `decltype`!
* `u` компилируется от чего угодно.
* `w` требует себе lvalue. От переменных окей, от `std::move` не окей. Тут много разногласий.
* `x` компилируется от чего угодно. Были сомнения с `std::move` и `c`.
* `y` требует себе rvalue. В частности, от `c` нельзя.

## Остальные задания [00:05]
* В 2 и 3
  * `move` из переменных делать надо в последний момент использования
  * `move` от вызова функции делать не надо
* В 4
  * Не нужны никакие касты! Не `const_cast`, а `void use() const`. Да и вообще неконстантный указатель можно передать вместо константного.
* В 5
  * Тонкая ошибка: `const S&&` — это не move constructor.
  * Даже rvalue-ссылка — это ссылка!

# План на лекцию
Глобально хотим научиться понимать на этапе компиляции, есть ли такой-то член в классе `T`
(member detection).
Но для этого нужно SFINAE и куча машинерии.
Поэтому сначала лирическое отступление про SFINAE, машинерию, и заодно добавим
сюда всякие полезности о подстройке кода под тип.
А вот уже в самом конце получим member detection idiom.

# Проверки на этапе компиляции
## `if constexpr`
* Хотим сделать метод `void printAll(const T &value)` для `int` и `vector<T>`, но без перегрузок.
* Разберём случай `int`: есть проверка `is_same_v<T, int>`. Не работает, потому что компилируется обе ветки.
* До C++17 приходилось писать шаблонный класс, специализировать, вызывать.
* В C++17 можно писать `if constexpr`. И даже работает автовывод возвращаемого `auto` типа функции.
* Даже внутри `if constexpr (false)` всё равно должен быть корректный синтаксис

## `static_assert`
* Проверяет условие на этапе компиляции. Если не удалось — ошибка компиляции.
* Если мы хотим сделать `static_assert(false)` внутри `if constexpr`, то будет ошибка
  компиляции всегда.
  * Причины технические. Надо обмануть компилятор.
  * Надо дать ему выражение, которое как-то теоретически может зависеть от `T`.
    Тогда съест.

## `std::conditional`
* Для выражений у нас есть тернарный оператор `cond ? t : f`, для `constexpr` тоже работает.
* Для типов такого нет. Надо писать свой if: `std::conditional<cond, T, F>`.
  * `typename std::conditional<true, T, F>::type` — это `T`.
  * `typename std::conditional<false, T, F>::type` — это `F`.
* Помогает объявлять поля.

# SFINAE
Можно большое объяснение прочитать тут: http://jguegant.github.io/blogs/tech/sfinae-introduction.html

## Определение
Substitution Failure Is Not An Error.

* Пример с `typename T::iterator` в параметре (`10-sfinae.cpp`). В возвращаемом значении тоже аналогично работает.
* Если при подстановке типовых параметров в функцию что-то не удалось вывести через `::`,
    то просто забиваем на конкретную перегрузку функции и пробуем следующие перегрузки.
* `static_assert` — это вообще всегда hard compilation error (ошибка компиляции, не SFINAE-игнорирование).

## Тонкости
* Работает в template alias вроде `_t`.
* Работает только на один уровень: если сделать свою структуру, а внутри `using`, то он должен быть нормальным.
  * Смотри отличия между `11a-sfinae.cpp` и `11b-sfinae.cpp`

## Использование для убирания перегрузок
### А зачем выключать перегрузки?
Чтобы работали всякие `is_move_constructible` — они смотрят только на объявление, не определение (`12-bad-static-assert.cpp`).

### Первый трюк (`13a-sfinae.cpp`)
Сделать возвращаемый тип вида `Something<T>::type` (`13a-sfinae.cpp`)

* Нам бы почти подошёл `conditional<Cond, T, F>`, но мы вместо `F` хотим SFINAE-ошибку,
  а не корректный тип.
* Такая штука есть, это4 `enable_if<Cond, T>`, который проверяет условие
  и в `::type` возвращает `T`.
  А если условие неверно, то получаем там SFINAE-ошибку.
* Есть псевдоним `enable_if_t`, он работает.

## Тонкость (`13b-sfinae.cpp`)
Есть мы используем для SFINAE-убирания шаблонный параметр не самой функции, а родительского класса, у нас проблема.
Примерно как со `static_assert(false);`

* Чтобы подцепить параметр от класса, надо `typename U = T` и проверять именно `U`.

### Второй трюк (`13c-sfinae.cpp`)
`typename = enable_if_t`

* Второй параметр у `enable_if` — это по умолчанию `void`, можно вообще убрать.
* Такое может работать с конструкторами (у них нет возвращаемого значения).
  * Для деструкторов ничего не спасает :(
* Тонкость: https://stackoverflow.com/a/31138725/767632
  * Если так выбирать между перегрузками, то надо, чтобы отличались типы функций,
    без учёта значений по умолчанию.
  * Поэтому `typename = enable_if_t` не сработает (получим тип `void`),
* Кстати, `clang` знает про `std::enable_if_t` и умеет выдавать красивые ошибки.

#### Лирическое отступление
В C++20 появились концепты (https://habr.com/ru/company/jugru/blog/467299/) и
requires clause, там можно вообще писать
```c++
int foo() requires std::is_same_v<T, int> {
}
```
Даже не нужен трюк с `U = T`.

Мы про это не будем.

### Третий трюк (`13d-sfinae.cpp`)
`enable_if_t<>* = nullptr` — сделали шаблонный параметр-значение
некоторого типа "указатель на что-то сложное" со значением `nullptr` по умолчанию.

* Это лечит проблему с перегрузками. Поэтому рекомендуется именно этот трюк.
* А ещё можно `void_t<>* = nullptr`, если просто проверить корректность выражения.
  * Так можно делать и в решении с `typename = void_t<>`, в целом
  * `void_t<>` всегда возвращает `void`.
  * Ещё на лекции был пример, что можно проверить корректность не выражения
    `std::declval<U>().begin()`, а `&U::begin`.
    * Это отголоски C++03, где не было `declval<>`.
    * Но тут проблема: нельзя напрямую проверить параметры и не работает,
      если `begin` перегружен.
    * ОШИБКА НА ЛЕКЦИИ: этому пофиг, если `begin` объявлен в родителе.

### Четвёртый трюк и variadic arguments (`14-sfinae.cpp`)
* Если нам надо вернуть из функции выражение `a + b` и мы хотим вырезать перегрузку,
  если оно некорректно, можно написать `auto foo(T a, T b) -> decltype(a + b)`.
  * Будет корректно работать SFINAE.
* Если нужна перегрузка, которая в приоритете ниже всех остальных,
  используем сишные вариативные функции (variadic function): https://en.cppreference.com/w/cpp/utility/variadic
  * `...` называется ellipsis/многоточие.
  * НА ЛЕКЦИИ НЕ БЫЛО: они не типобезопасные, не надо использовать.
  * НА ЛЕКЦИИ НЕ БЫЛО: Нормальный плюсовый метод тоже будет, но потом.
* ОШИБКА НА ЛЕКЦИИ: когда я показывал пример, я забыл убрать у `template<typename T> void add(...)` шаблонность.
  * Первая перегрузка ожидаемо честно отваливалась по SFINAE.
  * А вот вторая перегрузка отваливалась, потому что не могло вывести тип `T`.
  * `std::declval<>` писать не надо.

### Заключение
* Если подошло несколько условий, то дальше просто работают правила разрешения перегрузок.
  Можно получить ambiguous.

## Member detection idiom
### Базовое решение в C++11 (`15a-member-detection.cpp`)
Задумка: хотим сделать две перегрузки функции.
Если есть член `begin` — выбирается одна, иначе — вторая.

* Возьмём второй самую низкоприоритетную с `...`.
* А в первой сделаем через `void_t`.
* Тонкости:
  * Чтобы самая низкоприоритетная имела приоритет ниже, надо хотя бы один параметр передавать.
    Например, `nullptr`.

### Решение до C++11 (`15b-member-detection.cpp`)
* Нельзя `std::declval()`, поэтому придётся брать адрес члена и проверять его тип.
  * Либо не будет работать для перегруженных, либо придётся как-то форсировать тип.
  * НЕ БЫЛО НА ЛЕКЦИИ: при этом с типом есть тонкость: надо осторожно с `noexcept` с C++17.
* Нельзя `constexpr` или `decltype`, поэтому придётся получать знание о выбранной перегрузке
  через `sizeof`.
  * Определили `struct yes` и `struct no` разного размера, сравниваем `sizeof(test(....))` и `sizeof(yes)`.
* НЕ БЫЛО НА ЛЕКЦИИ: полное C++11 решение есть в `15c-member-detection.cpp`

### Концепты
В С++20 можно requires expression: `15d-member-detection.cpp`.
Там можно даже проверять возвращаемый тип.
Но у нас пока C++20 скорее нет.

# Рассказано на практике
* Специализации классов по условию:
  ```c++
  template<typename, typename = void> struct Foo;
  template<typename T> struct Foo<T, enable_if_t<Cond_v<T>> {};
  ```
* Трюк с `decltype` и запятой для member detection на самом деле работает:
  ```c++
  auto foo(T a) -> decltype(a.foo(), bool{}) {
      return true;
  }
  ```
