# Долги [00:08]
* Ошибка на прошлой лекции: обычная ссылка биндится только к lvalue, а не к glvalue.
  К xvalue не может.
  Следствие: `void push() & {}` не будет работать на временном объекте.
* Операторы преобразования типа бывают `explicit`.
  Например, когда пишем свой `unique_ptr`, может захотеться проверять его на `null`, как с обычным указателем:
  ```
  unique_ptr<Foo> f = ...;
  if (f) { ...  }
  // или
  if (!f) { ... }
  ```
  Можно сделать `operator bool()`.
  Но тогда неявные преобразования врубятся вообще везде, включая: `10 + f` (преобразовали в `bool`, преобразовали в `int`, сложили).
  В C++03 для этого использовались костыли под названием "Safe bool idiom" (там возвращали хитрый тип, который нельзя в `int`, но можно в `bool`),
  в C++11 можно написать `explicit operator bool()`.
  Тогда можно будет преобразовать в `bool`, но только явно, как с explicit конструкторами (`static_cast`).
  Конкретно для `bool` захардкожено, что можно использовать в: `if`/`while`/`for`, `!`, `||`, `&&`, `?:` и ещё паре мест.


# STL
## Название [00:02]
* "Standard Template Library" — стандартная библиотека шаблонов.
* Появилась около 1980 года отдельно от языка C++ и до его стандартизации.
* В стандарте термин "STL" не используется, вместо этого говорят:
  * Библиотека контейнеров — структуры данных для хранения объектов.
  * Библиотека итераторов — унифицированный доступ к элементам контейнеров.
  * Библиотека алгоритмов — для работы с последовательностями.
* На самом деле эти штуки друг с другом тесно связаны.

## Контейнеры [00:07]
Контейнер:

* Объект, который хранит другие объекты.
* Этот объект полностью управляет своей памятью и временем жизни хранимых объектов.
  В частности, у хранимых объектов должны быть:
  * Какие-то конструкторы (копирования, перемещения, создания с параметрами, в зависимости от вызываемых методов).
  * Если требуется, то какие-то операторы присваивания (копирования, перемещения).
  * Деструктор.
* Памятью управляет __аллокатор__ .
  * Он сложный: надо уметь выделять и удалять произвольные объекты в памяти (например, для `list<>` надо выделять внутренний тип).
  * Обычно хватает стандартного `std::allocator`.
    * Стандартный работает с `new`/`delete`, которые можно перегружать, но мы про это не будем, ссылка: https://habr.com/ru/post/490640/
  * Можно написать свой аллокатор, но мы про это не будем:
    * До С++11 они даже не могли иметь неглобального состояния.
    * Он, конечно, шаблонный, но надо уметь "перепривязываться" к произвольному типу. Тут я не уверен.
* Стандарт обещает какое-то время работы.
  Например, копирование `vector<T>` происходит за `O(n)` копирований `T`.
* Не очень любят кидающие move-конструкторы/move-присваивания (могут полететь гарантии исключений у хитрых операций).

Виды:

* Последовательные (хранят элементы в фиксированном пользователем порядке): `vector`, `deque`, `list`, `forward_list`.
* Ассоциативные (сортируют элементы по ключу): `map`, `set`, `multimap`, `multiset`.
* Неупорядоченные ассоциативные (хэшируют элементы по ключу): `unordered_*`.
* Адаптеры (надстраиваются над другими контейнерами): `queue`, `priority_queue`, `stack`.

## Операции с контейнерами [00:08]
* Контейнеры инварианты по типам.
  Нельзя написать:
  ```
  vector<Base*> v1;
  vector<Derived*> v2;
  v1 = v2;
  ```
* Всегда:
  * Конструктор по умолчанию (константа).
  * Конструктор перемещения (линия).
  * `a.swap(b)` и `swap(a, b)` (константа для всех, кроме `array`, элементы не трогает)
  * `.empty()` (константа)
  * `.size()` (константа)
  * Для обобщённого программирования (до изобретения `auto` или если надо поле сделать):
    * `vector<T>::value_type`
    * `vector<T>::reference_type`
    * `vector<T>::const_reference`
    * `vector<T>::size_type`
    * `vector<T>::difference_type`
* Если `CopyInsertable` (конструктор копирования у объекта):
  * Конструктор копирования.
* Если объекты можно сравнивать на `==`/`!=`:
  * `==`/`!=`

При этом по умолчанию:

* `noexcept`
  * `erase` (если только не бросит исключение move/copy оператор/конструктор в vector/deque)/`clear`/`swap`
  * `pop_back`/`pop_front` (если есть)
* Строгая гарантия
  * `insert`/`emplace` (если вставляет один элемент, а не много сразу; и то только если с нужного конца, см. vector/deque)
  * `push_back`/`push_front`/`emplace_back`/`emplace_front` (если есть)

## Итераторы и операции с ними [00:07]
У каждого контейнера также есть __итератор__ `vector<T>::iterator` (похож на `T*`) и `vector<T>::const_iterator` (похож на `const T*`).
Это некоторый небольшой объект, который умеет ходить по контейнеру (копируется и присваивается без исключений).
В общем случае это что угодно (например, у `map` надо обходить двоичное сбалансированное дерево).

* Итератор можно получить у любого контейнера:
  * Картинка с `begin`/`end`
  * `.begin()`/`.end()` — возвращает __итераторы__ на начало и элемент-после-конца `[begin; end)`. Типа указателей, но более общее.
  * `.cbegin()`/`.cend()` — аналогично, но итераторы константные (`const T*`).
* Итераторы можно разыменовывать:
  * `*i` и `i->foo()` у любого итератора: mutable/constant.
  * У mutable даже `*i = foo`.
* У любого контейнера есть специтератор, указывающий на элемент "после последнего".
  Его нельзя разыменовывать никогда и никак, это UB.
* Пара итераторов задаёт полуинтервал range.
  Если задали кривой, то UB.
* Все операции с итераторами работают за константу (амортизированно) или не работают вообще.

## Иерархия итераторов [00:10]
* Input/output iterator: можно сравнивать `==` и `!=`, можно `++r` и `r++`.
  При этом нельзя предполагать, что если `a == b`, то `++a == ++b`.
  Ещё есть алгоритмы `std::prev` и `std::next`.
  Считывать можно много раз, а вот записывать через `*r = foo` только один раз.
  Нельзя писать в input, нельзя читать из output.
  Пример: `istream_iterator`/`ostream_iterator`/`back_insert_iterator`/`front_insert_iterator`/`insert_iterator` для вставки в контейнер.
  Следствие: single pass algorithm.
* Forward iterator.
  Гарантируется, что итераторы ведут себя нормально: если `a == b`, то `++a == ++b`
  и если поменять копию итератора, то сам итератор не поменяется.
  Следствие: бывают multi pass algorithm.
* Bidirectional iterator. Добавили ещё и `--`.
* Random access iterator.
  Добавили `+=`, `+`, `-`, `<` и `>`, как в арифметике указателей.
  Вычитание даёт `difference_type`, но так можно только для связанных итераторов.

## Range-based for [00:07]
* Бывает `std::begin`/`std::end` и range-based-for:
  * https://cppinsights.io/
  * `std::begin`/`std::end` вызывают внутренние `begin`/`end` и перегружены для обычных массивов.
  * Тонкость: в `for (int &x : foo().bar()) { ... }` временное значение `foo()` не живёт, а `bar()` живёт.
  * Range-based for — синтаксический сахар для https://en.cppreference.com/w/cpp/language/range-for :
    ```
    for (DECL : EXPR) BODY
    // ~~~~
    {
        auto range = EXPR;
        auto begin = std::begin(range);
        auto end = std::begin(end);
        for (auto it = begin; it != end; ++it) {
            DECL = *it;
            BODY
        }
    }
    ```
* Не стоит менять то, по чему итерируемся

## Прочие операции с итераторами [00:09]
* Бывает `std::advance`, `std::distance`. Работают за константу для random access (вызвать `+` и `-`) и линию для остальных (в цикле).
* Бывают адаптеры:
  * `reverse_iterator` от bidirectional.
  * Упражнение: написать свою обёртку `make_reversed(begin, end)`, которая возвращает прокси-контейнер, у которого
    `begin` и `end` взяты из `reverse_iterator`.
* Можно создавать контейнер от пары итераторов, скопирует.
* Итераторы, ссылки на элементы и указатели инвалидируются:
  * Если инвалидировался, то больше ничего нельзя делать.
    Пример: перевыделение памяти вектора.
  * `swap` ничего не инвалидирует (кроме как в `array`).
  * При `move` технически могут инвалидироваться. Почему-то стандарт не запрещает.
  * Вывод: для своих контейнеров может быть разумно реализовывать `move` через `swap`.
    И оба ничего не будут инвалидировать.

## Последовательные контейнеры [00:08]
* Хранят элементы в фиксированном пользователем порядке.
* `vector`, `forward_list`, `list`, `deque`.
* Отдельно `array`, потому что у него фиксированное количество элементов.
* У них бывает:
  * `Container(n, t)` — `n` копий `t`, требует `CopyInsertable`.
  * Оператор присваивания есть, требует ещё и `CopyAssignable`.
  * `a.emplace(p, args..)` — в точке `p` создаётся новый объект, конструктору аргументы `args..`. Для `vector` и `deque` требуется `MoveInsertable`+`MoveAssignable`.
    Возвращает итератор на вставленный элемент.
  * `a.insert(p, t)` — в точке `p` создаётся копия, надо `CopyInsertable` или `MoveInsertable` (в зависимости от категории `t`).
    Есть ещё версия, которая вставляет `n` копий, которая вставляет полуинтервал между парой итераторов, контейнер целиком...
    Возвращает итератор на первый вставленный элемент (или на `p`, если их нет).
  * `a.erase(p)` — удалить элемент `p`. Для `vector` и `deque` требуется `MoveAssignable`.
    Есть ещё версия, которая удаляет полуинтервал.
    Возвращает итератор на элемент после последнего удалённого (или на `end`).
  * `a.assign(begin, end)` — переприсвоить элементы на значения из полуинтервала (или контейнера, или сделать `n` копий).
    Это круче `=`, когда мы а) не хотим лишние копии; или б) типы контейнеров не сошлись: `vector<Base*> v; vector<Derived*> d; v.assign(d);`
* У некоторых бывает:
  * `front()`/`back()` — возвращают ссылки
  * `{emplace,push,pop}_{front,back}` — ничего не возвращают; `emplace` возвращает ссылку, начиная с C++17.
  * `a[n]` — возвращают ссылку
  * `a.at(n)` — возвращает ссылку и кидает `out_of_range` если выход за границу.

## array [00:01]
* Хранится на стеке без динамической памяти.
* Из необычного: есть метод `fill(value)`, у остальных контейнеров такого нет.

## vector [00:03]
* Обязан хранить элементы в памяти подряд.
  В стандарте прописано, что должна работать арифметика указателей.
* За амортизированную константу работает с хвостом.
* Есть `capacity()` — размер текущего буфера памяти.
* Есть `size()` — реальный размер.
* Реаллокация инвалидирует все итераторы, указатели, ссылки.
* Можно вызвать `reserve` — увеличить `capacity` хотя бы до аргумента. Реаллокация.
* `shrink_to_fit()` — вежливо просит уменьшить `capacity()` до `size()`.
  Необязательно (вдруг SSO). Реаллокация.
* `T* data()` — возвращает чистый указатель на данные.
* Удаление реаллокацию не вызывает, но инвалидирует указатели и ссылки на элементы после `erase`.

## `vector<bool>` [00:02]
* Больше нет требования на непрерывность.
* Есть __рекомендация__ хранить упаковано в биты.
  Меньше памяти, но потенциально медленнее.
  Когда-то казалось хорошей идеей.
* Есть `flip()` — перевернуть все значения. У остальных такого нет.
* Есть проблемы с прокси-объектами:
  * http://alenacpp.blogspot.com/2005/06/vector.html
  * http://www.gotw.ca/publications/mill09.htm

## deque [00:05]
* Умеет вставлять/удалять начало и в конец за константу (амортизированную?);
  а ещё умеет за константу получать i-й элемент.
  * https://ru.stackoverflow.com/a/900583/210302
  * На самом деле это как вектор, только запас в две стороны.
  * А чтобы много не копировать, обычно ещё дополнительно хранит элементы не последовательно, а блоками фиксированного размера (стандарт не обещает).
    Тогда надо перевыделять только буфер указателей.
* `resize`: либо `pop_back()`, либо вставили сколько-то элементов в конец.
* Вставка в середину bнвалидирует все итераторы и ссылки на элементы.
* Вставка в любой из концов инвалидирует только итераторы.
* Сложность вставки: линия от расстояния до ближайшего конца.
* Удаление:
  * Если удалили последний, то инвалидирует `end()` и итераторы на все удалённые.
  * Если удалили первый, но не последний, то только удалённые.
  * Если удалили из середины, то вообще всё.
  * Линия от расстояния до ближайшего конца.
