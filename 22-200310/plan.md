# Долги [00:10]
* Ошибка на прошлой лекции: обычная ссылка биндится только к lvalue, а не к glvalue.
  К xvalue не может.
  Следствие: `void push() & {}` не будет работать на временном объекте.
* Операторы преобразования типа бывают `explicit`.
  Например, когда пишем свой `unique_ptr`, может захотеться проверять его на `null`, как с обычным указателем:
  ```
  unique_ptr<Foo> f = ...;
  if (f) { ...  }
  // или
  if (!f) { ... }
  ```
  Можно сделать `operator bool()`.
  Но тогда неявные преобразования врубятся вообще везде, включая: `10 + f` (преобразовали в `bool`, преобразовали в `int`, сложили).
  В C++03 для этого использовались костыли под названием "Safe bool idiom" (там возвращали хитрый тип, который нельзя в `int`, но можно в `bool`),
  в C++11 можно написать `explicit operator bool()`.
  Тогда можно будет преобразовать в `bool`, но только явно, как с explicit конструкторами (`static_cast`).
  Конкретно для `bool` захардкожено, что можно использовать в: `if`/`while`/`for`, `!`, `||`, `&&`, `?:` и ещё паре мест.


# STL
## Название [00:02]
* "Standard Template Library" — стандартная библиотека шаблонов.
* Появилась около 1980 года отдельно от языка C++ и до его стандартизации.
* В стандарте термин "STL" не используется, вместо этого говорят:
  * Библиотека контейнеров — структуры данных для хранения объектов.
  * Библиотека итераторов — унифицированный доступ к элементам контейнеров.
  * Библиотека алгоритмов — для работы с последовательностями.
* На самом деле эти штуки друг с другом тесно связаны.

## Контейнеры [00:07]
Контейнер:

* Объект, который хранит другие объекты.
* Этот объект полностью управляет своей памятью и временем жизни хранимых объектов.
  В частности, у хранимых объектов должны быть:
  * Какие-то конструкторы (копирования, перемещения, создания с параметрами, в зависимости от вызываемых методов).
  * Если требуется, то какие-то операторы присваивания (копирования, перемещения).
  * Деструктор.
* Памятью управляет __аллокатор__ .
  * Он сложный: надо уметь выделять и удалять произвольные объекты в памяти (например, для `list<>` надо выделять внутренний тип).
  * Обычно хватает стандартного `std::allocator`.
    * Стандартный работает с `new`/`delete`, которые можно перегружать, но мы про это не будем, ссылка: https://habr.com/ru/post/490640/
  * Можно написать свой аллокатор, но мы про это не будем:
    * До С++11 они даже не могли иметь неглобального состояния.
    * Он, конечно, шаблонный, но надо уметь "перепривязываться" к произвольному типу. Тут я не уверен.
* Стандарт обещает какое-то время работы.
  Например, копирование `vector<T>` происходит за `O(n)` копирований `T`.
* Не очень любят кидающие move-конструкторы/move-присваивания (могут полететь гарантии исключений у хитрых операций).

Виды:

* Последовательные (хранят элементы в фиксированном пользователем порядке): `vector`, `deque`, `list`, `forward_list`.
* Ассоциативные (сортируют элементы по ключу): `map`, `set`, `multimap`, `multiset`.
* Неупорядоченные ассоциативные (хэшируют элементы по ключу): `unordered_*`.
* Адаптеры (надстраиваются над другими контейнерами): `queue`, `priority_queue`, `stack`.

## Операции с контейнерами:
* Всегда:
  * Конструктор по умолчанию (константа).
  * Конструктор перемещения (линия).
  * `a.swap(b)` и `swap(a, b)` (константа для всех, кроме `array`, элементы не трогает)
  * `.empty()` (константа)
  * `.size()` (константа)
  * Для обобщённого программирования (до изобретения `auto` или если надо поле сделать):
    * `vector<T>::value_type`
    * `vector<T>::reference_type`
    * `vector<T>::const_reference`
    * `vector<T>::size_type`
    * `vector<T>::difference_type`
* Если `CopyInsertable` (конструктор копирования у объекта):
  * Конструктор копирования.
* Если объекты можно сравнивать на `==`/`!=`:
  * `==`/`!=`

При этом:

* `noexcept`
  * `erase`/`clear`/`swap`
  * `pop_back`/`pop_front` (если есть)
* Строгая гарантия
  * `insert`/`emplace` (если вставляет один элемент, а не много сразу)
  * `push_back`/`push_front`/`emplace_back`/`emplace_front` (если есть)

## Итераторы и операции с ними
У каждого контейнера также есть __итератор__ `vector<T>::iterator` (похож на `T*`) и `vector<T>::const_iterator` (похож на `const T*`).
Это некоторый небольшой объект, который умеет ходить по контейнеру (копируется и присваивается без исключений).
В общем случае это что угодно (например, у `map` надо обходить двоичное сбалансированное дерево).

* Итератор можно получить у любого контейнера:
  * Картинка с `begin`/`end`
  * `.begin()`/`.end()` — возвращает __итераторы__ на начало и элемент-после-конца `[begin; end)`. Типа указателей, но более общее.
  * `.cbegin()`/`.cend()` — аналогично, но итераторы константные (`const T*`).
* Итераторы можно разыменовывать:
  * `*i` и `i->foo()` у любого итератора: mutable/constant.
  * У mutable даже `*i = foo`.
* У любого контейнера есть специтератор, указывающий на элемент "после последнего".
  Его нельзя разыменовывать никогда и никак, это UB.
* Пара итераторов задаёт полуинтервал range.
  Если задали кривой, то UB.
* Все операции с итераторами работают за константу (амортизированно) или не работают вообще.
* Иерархия:
  * Input/output iterator: можно сравнивать `==` и `!=`, можно `++r` и `r++`.
    При этом нельзя предполагать, что если `a == b`, то `++a == ++b`.
    Ещё есть алгоритмы `std::prev` и `std::next`.
    Считывать можно много раз, а вот записывать через `*r = foo` только один раз.
    Нельзя писать в input, нельзя читать из output.
    Пример: `istream_iterator`/`ostream_iterator`/`back_insert_iterator`/`front_insert_iterator`/`insert_iterator` для вставки в контейнер.
    Следствие: single pass algorithm.
  * Forward iterator.
    Гарантируется, что итераторы ведут себя нормально: если `a == b`, то `++a == ++b`
    и если поменять копию итератора, то сам итератор не поменяется.
    Следствие: бывают multi pass algorithm.
  * Bidirectional iterator. Добавили ещё и `--`.
  * Random access iterator.
    Добавили `+=`, `+`, `-`, `<` и `>`, как в арифметике указателей.
    Вычитание даёт `difference_type`, но так можно только для связанных итераторов.
* Бывает `std::begin`/`std::end` и range-based-for:
  * https://cppinsights.io/
  * `std::begin`/`std::end` вызывают внутренние `begin`/`end` и перегружены для обычных массивов.
  * Тонкость: в `for (int &x : foo().bar()) { ... }` временное значение `foo()` не живёт, а `bar()` живёт.
* Бывает `std::advance`, `std::distance`. Работают за константу для random access и линию для остальных.
* Бывают адаптеры:
  * `reverse_iterator` от bidirectional.
* Можно создавать контейнер от пары итераторов, скопирует.
* Итераторы, ссылки на элементы и указатели инвалидируются:
  * Если инвалидировался, то больше ничего нельзя делать.
    Пример: перевыделение памяти вектора.
  * При `move` технически могут инвалидироваться.
  * `swap` ничего не инвалидирует.

## Последовательные контейнеры
* Хранят элементы в фиксированном пользователем порядке.
* `vector`, `forward_list`, `list`, `deque`.
* Отдельно `array`, потому что у него фиксированное количество элементов.
* У них бывает:
  * `Container(n, t)` — `n` копий `t`, требует `CopyInsertable`.
  * Оператор присваивания есть, требует ещё и `CopyAssignable`.
  * `a.emplace(p, args..)` — в точке `p` создаётся новый объект, конструктору аргументы `args..`. Для `vector` и `deque` требуется `MoveInsertable`+`MoveAssignable`.
    Возвращает итератор на вставленный элемент.
  * `a.insert(p, t)` — в точке `p` создаётся копия, надо `CopyInsertable` или `MoveInsertable` (в зависимости от категории `t`).
    Есть ещё версия, которая вставляет `n` копий, которая вставляет полуинтервал между парой итераторов, контейнер целиком...
    Возвращает итератор на первый вставленный элемент (или на `p`, если их нет).
  * `a.erase(p)` — удалить элемент `p`. Для `vector` и `deque` требуется `MoveAssignable`.
    Есть ещё версия, которая удаляет полуинтервал.
    Возвращает итератор на элемент после последнего удалённого (или на `end`).
  * `a.assign(begin, end)` — переприсвоивать элементы на значения из полуинтервала (или контейнера, или сделать `n` копий).
    Это круче `=`, когда мы а) не хотим лишние копии; или б) типы контейнеров не сошлись: `vector<Base*> v; vector<Derived*> d; v.assign(d);`
* У некоторых бывает:
  * `front()`/`back()` — возвращают ссылки
  * `{emplace,push,pop}_{front,back}` — ничего не возвращают; `emplace` возвращает ссылку, начиная с C++17.
  * `a[n]` — возвращают ссылку
  * `a.at(n)` — возвращает ссылку и кидает `out_of_range` если выход за границу.

## array
* Хранится на стеке без динамической памяти.
* Из необычного: есть метод `fill(value)`, у остальных контейнеров такого нет.

## vector
* Обязан хранить элементы в памяти подряд.
  В стандарте прописано, что должна работать арифметика указателей.
* За амортизированную константу работает с хвостом.
* Есть `capacity()` — размер текущего буфера памяти.
* Есть `size()` — реальный размер.
* Реаллокация инвалидирует все итераторы, указатели, ссылки.
* Можно вызвать `reserve` — увеличить `capacity` хотя бы до аргумента. Реаллокация.
* `shrink_to_fit()` — вежливо просит уменьшить `capacity()` до `size()`.
  Необязательно (вдруг SSO). Реаллокация.
* `T* data()` — возвращает чистый указатель на данные.
* Вставки могут вызвать реаллокацию и инвалидацию. Классический баг:
  ```
  int foo(vector<int> &v) {
      v.push_back(10);
      v.push_back(20);
      return 30;
  }
  //
  vector<int> v = {5};
  v[0] = foo(v);
  ```
* Удаление реаллокацию не вызывает, но инвалидирует указатели и ссылки на элементы после `erase`.

## `vector<bool>`
* Больше нет требования на непрерывность.
* Есть __рекомендация__ хранить упаковано в биты.
  Меньше памяти, но потенциально медленнее.
  Когда-то казалось хорошей идеей.
* Есть `flip()` — перевернуть все значения. У остальных такого нет.
* Есть проблемы с прокси-объектами:
  * http://alenacpp.blogspot.com/2005/06/vector.html
  * http://www.gotw.ca/publications/mill09.htm

## deque
* Умеет вставлять/удалять начало и в конец за константу (амортизированную?);
  а ещё умеет за константу получать i-й элемент.
  * https://ru.stackoverflow.com/a/900583/210302
  * На самом деле это как вектор, только запас в две стороны.
  * А чтобы много не копировать, обычно ещё дополнительно хранит элементы не последовательно, а блоками фиксированного размера (стандарт не обещает).
    Тогда надо перевыделять только буфер указателей.
* `resize`: либо `pop_back()`, либо вставили сколько-то элементов в конец.
* Вставка в середину bнвалидирует все итераторы и ссылки на элементы.
* Вставка в любой из концов инвалидирует только итераторы.
* Сложность вставки: линия от расстояния до ближайшего конца.
* Удаление:
  * Если удалили последний, то инвалидирует `end()` и итераторы на все удалённые.
  * Если удалили первый, но не последний, то только удалённые.
  * Если удалили из середины, то вообще всё.
  * Линия от расстояния до ближайшего конца.

## list
* Двусвязный список, удаление всегда за линию от количества элементов.
* Нельзя random access, итераторы и указатели не инвалидируются.
  Можно идти с начала, можно идти с конца за константу.
* Можно перемещать элементы из одного списка в другой:
  * `splice(pos, x)` (если `x != this`): утащили все элементы из `x` (это контейнер или итератор из одного элемента) в позицию `pos`.
    Итераторы и ссылки тоже переехали.
    Всё за константу.
  * `splice(pos, begin, end)`: перетащили внутри себя элементы за константу на другое место.
    А если это был другой список, то линия (потому что надо пересчитать `size`; до C++11 было по-другому).
* Есть `remove`, `remove_if`, `unique`, `merge`, `reverse`, стабильный `sort`: аналогично алгоритмам, но не инвалидируют.

## forward_list
* Односвязный список, детально не разбираем.
* Куча проблем с тем, что нельзя просто взять и сделать `insert`, надо `insert_after`.
  Свои методы в больших количествах.

## string

* Ещё бывают адаптеры, 
