# Долги [00:20]
## Свои манипуляторы [00:10]
Ошибки в описании своих манипуляторов с лекции.

* Так работает:
  ```
  std::ostream hex(std::ostream &os) { ... return os; }
  os << hex;
  ```
  Но это только для функций: `ostream& operator<< (ostream& (*pf)(ostream&));`
* А если мы пишем свой манипулятор вроде `write_le_int32`,
  то нам надо, чтобы `write_le_int32(10)` было неким `X`, для
  чего есть `operator<<`.
  При этом `X` должен быть разный в зависимости от аргумента `write_le_int32`.
* Самое простое: сделать класс и тогда у нас там был вызов конструктора.
  ```
  struct write_le_int32 {
      /*explicit*/ write_le_int32(int32_t _val) : val(_val) {}
      friend std::ostream& operator<<(std::ostream &os, const write_le_int32 &d);  // почему const&?
  private:
      int32_t val;
  };
  ```
* C `read_le_int32` сложнее, потому что там надо брать ссылку в параметр конструктора.
  А в поле сохранять ссылку или указатель.
  Лучше ссылку, имхо, но тогда нельзя будет копировать (и не надо!).

## Наследование и forward declaration [00:10]
* В предыдущем пункте нам в `bin_manip.h` не нужно полное определение `ostream`.
  Достаточно forward-declaration:
  ```
  class ostream;
  ```
  Для этого есть `#include <iosfwd>`, который сильно быстрее компилируется.
* При этом в реализации `bin_manip.cpp` уже надо будет честно `#include <iostream>`.
* Проблема из домашки: объявили в заголовке `bin_manip.h`:
  ```
  std::ostream& operator<<(std::ostream&, write_le_int32&);
  ```
  и вызвали:
  ```
  std::ofstream f(...);
  f << write_le_int32(10);
  ```
  Компилятор сказал: нельзя вызвать оператор от `(std::ofstream&, const write_le_int32&)`.
  Но есть же наследование!
* Причина: `#include <iostream>` не определяет `class ofstream`, он только включает `<iosfwd>`
  и определяет обычные `istream`/`ostream`.
  Чтобы компилировалось быстрее.
* Поэтому если нам в единице трансляции надо использовать хитрые перегрузки,
  то обязательно `#include <fstream>`.
  Более того: это нельзя сделать в `bin_manip.h`, потому что мало ли какие
  наследники будут у `istream`!
  Это забота `employees.cpp`.

# Model, ViewController [00:30]
## Зависимости между частями программы [00:05]
* Пусть есть два класса:
  ```
  struct A {
  private:
      B *b;
  };
  struct B {
  };
  ```
  Тогда класс `A` зависит от `B`.
  Где бы не использовали `A`, нужен также `B`; нельзя протестировать отдельно, нельзя отцепить друг от друга.
* Это может быть проблема, если класс `B` использует что-то специфичное.
  Например, файловый или консольный ввод-вывод.
  Если захотим перетащить `A` в графическое приложение, будет странно.
* Зато `B` можно использовать отдельно.
* По этому поводу стараются не делать циклов в зависимостях.
* В качестве бонуса: когда тестируем `B`, не думаем про `A` вообще.
  На этапе проектирования думаем, а вот при реализации уже нет.

## Model [00:10]
* В большой домашке будут крестики-нолики.
  Надо будет не просто сделать, а разбить определённым образом на части.
* Выделить "Модель игры" (Model) в отдельный класс.
  Экземпляр класса хранит состояние игры и умеет с ним работать
  (делать ходы, вычислять победителя).
   ```
   int cells[10][10];  // Лучше enum
   bool move(int x, int y, int sign)  // Лучше enum?
   int isWin()  // Лучше enum и переименовать?
   int getCell(int x, int y)
   ```
   * Так мы можем протестировать модель отдельно от всего остального.
   * Так модель может работать одинаково в разных интерфейсах:
     можно сделать консоль, можно GUI, можно многопользовательскую игру
     для сайта.
   * Модель можно даже передавать от одного интерфейса к другому!

## "View" [00:05]
* В этой домашке оставшуюся часть можно так и оставить.
  Мы её будем называть "Представление" (View), тоже выделим в отдельный класс.
  Это нестандартный термин.
  Экземпляр умеет брать модель и запускать на ней игру (`void runGame(Model m)`).
   * Можно сделать несколько представлений: один чисто консольный (основное задание),
     один перерисовывающий экран (бонусное задание).
   * Можно попросить разных участников команды писать разные представления.
* В целом тут пока класс не особо нужен, потому что есть только метод `runGame()`.

## Model-View-Controller [00:10]
* Можно пойти дальше и сказать, что между всеми представлениями
  есть логика "делай ходы, пока игра не закончилась, отобрази победителя".
* Тогда можно распилить "View" на View и Controller:
  ```
  class View {
      View(const Model &m);
      void redrawField();
      void gameFinished();
      pair<int, int> getTurn();
  };
  class Controller {
      Controller(const Model &m, const View &v);
      void playGame();
  };
  ```
  * Теперь у нас логика игры — в Controller.
    Можем тестировать независимо от View, если предоставим
    свой класс-заглушку View.
* Тут уже может быть не очень ясно, зачем класс Controller,
  потому что он один.
* А вот в веб-приложении у нас может быть десяток страниц,
  все со своими контроллерами (регистрация, лента новостей, личные сообщения)...
  И View могут переиспользоваться между контроллерами и другими View
  (например, "комментарий к посту" может показываться в ленте и на странице поста).
* Это уже классический шаблон "Model-View-Controller".
  Но в домашке мы View-Controller склеили в один класс для простоты.
  Model обычно выделяется на халяву, а вот удобно разделить View-Controller нетривиально.

# Автотесты [00:15]
## Идеология [00:05]
* Хотим написать десяток методов, которые автоматически проверяют
  корректность программы: создать класс, запустить методы, проверить результат.
* При этом хочется:
  * Если что-то неверно — быстро понять, что именно.
    Название теста, ожидаемый результат, реальный результат,
    а не просто "всё упало".
  * Воспроизводимые тесты без рандома (иначе не отладить).
  * Запускать только кусочек тестов (например, если их тысяча).
  * Группировка тестов (например, протестировать только кусок программы).
  * Писать тесты приятно.
* "Юнит-тесты" тестируют публичные методы конкретных классов.
  Ещё бывают модульные, интеграционные — они просто тестируют
  куски побольше.
* Обычно используют готовые фреймворки вроде Google Test, doctest,
  но в домашке напишем свой небольшой, чтобы убедиться, что магии нет.

## Реализация [00:10]
* Сделаем класс "набор тестов":
  ```
  class TestCase {
    static bool check(bool exp/*, const char* file, int line, const char* func*/);
    virtual void runAllTests() = 0;
  private:
    static int total;
    static int failed;
  };
  ```
* Каждый тест будет отдельным методом наследника, а `runAllTests` их всех по очереди вызовет.
  ```
  class ModelTestCase : public TestCase {
    void testEmpty() {
      Model m;
      TestCase::check(!m.isWin(), ...);
    }
    void testXWin() {
      Model m;
      ...
      TestCase::check(m.isWin(), ...);
    }
    void runAllTests() override {
      testEmpty();
      testXWin();
    }
  };
  ```
* `check` вызывается в конце теста.
  Увеличивает счётчик тестов и, если что, счётчик проваленных тестов и выводит сообщение об ошибке.

## Бонусы [00:10]
* Можно добавить в `check` параметров.
  А чтобы проще использовать, напишем макрос:
  `#define DO_CHECK(exp) TestCase::check(exp, __FILE__, __LINE__, __FUNC__)`
* Дальше можно добавить `check_eq` с двумя параметрами, который выведет сообщение об ошибке через `cout`:
  `#define DO_CHECK_EQ(a, b) TestCase::check(a, b, __FILE__, __LINE__, __FUNC__)
* Зачем здесь вообще класс `TestCase`? Можно же свободными функциями.
  Пока незачем, но можно добавить `virtual const char* name() = 0;`, сохранить
  все `TestCase` в массив и из параметров командной строки узнавать,
  с какими именами запустить тесты.
* А потом ещё можно авторегистрацию тестов сделать.
  Снова через макрос, который разворачивает в класс, который в конструкторе
  вызывает функцию "зарегистрируй тест".
